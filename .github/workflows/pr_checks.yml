name: Pull Request Checks

on:
  pull_request:
    types: [opened, reopened, synchronize, edited, ready_for_review, demilestoned]
  issue_comment:
    types: [created]

# Add concurrency to cancel in-progress runs on new commits
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  statuses: write

jobs:
  #################################################
  # COMMENT CHECK - For manual trigger via !check
  #################################################
  check-manual-trigger:
    if: ${{ github.event_name == 'issue_comment' && github.event.issue.pull_request }}
    name: üîç Check Manual Trigger
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check-command.outputs.should_run }}
      pr_number: ${{ steps.get-pr.outputs.pr_number }}
    steps:
      - name: Check for command and owner
        id: check-command
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const comment = context.payload.comment.body;
            const commenter = context.payload.comment.user.login;

            // Check if the comment contains the command and is from repo owner
            // More strict matching: must be at beginning of line and a standalone word
            const isCommand = /^!check\b/.test(comment.trim());
            const isRepoOwner = context.payload.repository.owner.login === commenter;

            const shouldRun = isCommand && isRepoOwner;

            console.log(`Comment: "${comment}"`);
            console.log(`Commenter: ${commenter}`);
            console.log(`Is Owner: ${isRepoOwner}`);
            console.log(`Is Command: ${isCommand}`);
            console.log(`Should Run: ${shouldRun}`);

            core.setOutput('should_run', shouldRun.toString());

            // Comment with acknowledgment if it's the command
            if (isCommand) {
              if (isRepoOwner) {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: '‚úÖ PR check workflow manually triggered by repository owner.'
                });
              } else {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: '‚ö†Ô∏è Only repository owners can trigger the PR check workflow manually.'
                });
              }
            }

      - name: Get PR number
        id: get-pr
        if: ${{ steps.check-command.outputs.should_run == 'true' }}
        uses: actions/github-script@v7.0.1
        with:
          script: |
            // Comment is on a PR issue
            const prNumber = context.issue.number;
            console.log(`PR Number: ${prNumber}`);
            core.setOutput('pr_number', prNumber);

  #################################################
  # INITIAL CHECK - Author detection for PR events
  #################################################
  initial-author-check-pr:
    if: ${{ github.event_name == 'pull_request' }}
    name: üîç Initial PR Author Check
    uses: ./.github/workflows/check_bot_author.yml
    with:
      pr_number: ${{ github.event.pull_request.number }}
      event_type: 'pull_request'

  #################################################
  # INITIAL CHECK - Author detection for manual triggers
  #################################################
  initial-author-check-manual:
    needs: [check-manual-trigger]
    if: ${{ github.event_name == 'issue_comment' && needs.check-manual-trigger.outputs.should_run == 'true' }}
    name: üîç Initial PR Author Check (Manual)
    uses: ./.github/workflows/check_bot_author.yml
    with:
      pr_number: ${{ needs.check-manual-trigger.outputs.pr_number }}
      event_type: 'issue_comment'

  #################################################
  # CHANGELOG CHECKS
  #################################################
  changelog-update-dependabot:
    name: üìù Update Changelog (Dependabot)
    needs: [initial-author-check-pr, initial-author-check-manual]
    if: |
      always() &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_dependabot == 'true') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_dependabot == 'true')
      )
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    outputs:
      changelog_updated: ${{ steps.extract-info.outputs.has_match }}
      package_name: ${{ steps.extract-info.outputs.package }}
      from_version: ${{ steps.extract-info.outputs.from_version }}
      to_version: ${{ steps.extract-info.outputs.to_version }}
      dep_type: ${{ steps.update-changelog.outputs.dep_type }}
      commit_sha: ${{ steps.update-changelog.outputs.commit_sha }}
    steps:
      - uses: actions/checkout@v4.2.2
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Extract dependency information
        id: extract-info
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          # Pattern for conventional commit format: build(deps): bump package from version to version
          if [[ "$PR_TITLE" =~ build\(deps.*\):\ bump\ ([^\ ]+)\ from\ ([0-9]+[\.0-9]*)\ to\ ([0-9]+[\.0-9]*) ]]; then
            PACKAGE="${BASH_REMATCH[1]}"
            FROM_VERSION="${BASH_REMATCH[2]}"
            TO_VERSION="${BASH_REMATCH[3]}"
            echo "package=$PACKAGE" >> $GITHUB_OUTPUT
            echo "from_version=$FROM_VERSION" >> $GITHUB_OUTPUT
            echo "to_version=$TO_VERSION" >> $GITHUB_OUTPUT
            echo "has_match=true" >> $GITHUB_OUTPUT
          else
            echo "has_match=false" >> $GITHUB_OUTPUT
          fi

      - name: Update CHANGELOG.md
        id: update-changelog
        if: steps.extract-info.outputs.has_match == 'true'
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          CHANGELOG_FILE="public/CHANGELOG.md"
          PACKAGE="${{ steps.extract-info.outputs.package }}"
          FROM_VERSION="${{ steps.extract-info.outputs.from_version }}"
          TO_VERSION="${{ steps.extract-info.outputs.to_version }}"

          if [ ! -f "$CHANGELOG_FILE" ]; then
            echo "Error: CHANGELOG.md not found at $CHANGELOG_FILE"
            exit 1
          fi

          # Determine the type of dependency
          DEP_TYPE="dependency"
          if [[ "$PR_TITLE" == *"deps-dev"* ]]; then
            DEP_TYPE="dev dependency"
          fi
          echo "dep_type=$DEP_TYPE" >> $GITHUB_OUTPUT

          # Find the first version section line and the next section (if any)
          FIRST_VERSION_LINE=$(grep -n "^## " "$CHANGELOG_FILE" | head -1 | cut -d: -f1)
          NEXT_VERSION_LINE=$(grep -n "^---" "$CHANGELOG_FILE" | head -1 | cut -d: -f1)

          # If there's no next section (no "---" line found), insert before the end of the file
          if [ -z "$NEXT_VERSION_LINE" ]; then
            INSERT_LINE="$(($(wc -l < "$CHANGELOG_FILE")+1))"
          else
            # Insert right before the "---" separator
            INSERT_LINE="$((NEXT_VERSION_LINE-1))"
          fi

          # Format the changelog entry
          ENTRY="- Bump $DEP_TYPE \`$PACKAGE\` from $FROM_VERSION to $TO_VERSION"

          # Insert the entry before the separator line or at the end of file
          sed -i "${INSERT_LINE}i $ENTRY" "$CHANGELOG_FILE"

          # Commit and push the changes
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          git add "$CHANGELOG_FILE"
          git commit -m "docs: update changelog with $PACKAGE dependency bump"
          git push

          # Get the commit SHA of the new commit we just pushed
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "Updated changelog with commit: $COMMIT_SHA"

      - name: Comment on PR about changelog update
        if: steps.extract-info.outputs.has_match == 'true'
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const packageName = '${{ steps.extract-info.outputs.package }}';
            const fromVersion = '${{ steps.extract-info.outputs.from_version }}';
            const toVersion = '${{ steps.extract-info.outputs.to_version }}';
            const depType = '${{ steps.update-changelog.outputs.dep_type }}';

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `üìù **Changelog Automatically Updated**\n\nA changelog entry has been automatically added for this Dependabot PR:\n\n- Bump ${depType} ${packageName} from ${fromVersion} to ${toVersion}`
            });

  changelog-check-user:
    name: üìã Check Changelog (User PR)
    needs: [initial-author-check-pr, initial-author-check-manual]
    if: |
      always() &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'false') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'false')
      )
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.changelog-check.outputs.changed }}
    steps:
      - uses: actions/checkout@v4.2.2
      - name: Check for changelog changes
        id: changelog-check
        run: |
          git fetch origin ${{ github.base_ref }} --depth=1
          CHANGELOG_CHANGED=$(git diff --name-only origin/${{ github.base_ref }} | grep -c "public/CHANGELOG.md" || true)
          echo "changed=$CHANGELOG_CHANGED" >> $GITHUB_OUTPUT

  changelog-enforce-user:
    name: ‚úÖ Enforce Changelog (User PR)
    needs: [initial-author-check-pr, initial-author-check-manual, changelog-check-user]
    if: |
      always() &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'false') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'false')
      )
    runs-on: ubuntu-latest
    outputs:
      should_block: ${{ steps.check-status.outputs.should_block }}
    steps:
      - uses: actions/checkout@v4.2.2

      - name: Handle changelog enforcement
        id: check-status
        run: |
          HAS_CHANGES="${{ needs.changelog-check-user.outputs.has_changes }}"

          # Always try to remove the label first if changes exist
          if [[ "$HAS_CHANGES" != "0" ]]; then
            echo "Changelog changes detected - removing label if it exists"
            gh pr edit ${{ github.event.pull_request.number }} --remove-label "Changelog needed" 2>/dev/null || true
          fi

          # For non-bot PRs, check if changelog was updated
          if [[ "$HAS_CHANGES" == "0" ]]; then
            echo "User PR detected without changelog changes - blocking"
            gh label create "Changelog needed" --color FF0000 --description "Changelog update required" 2>/dev/null || true
            gh pr edit ${{ github.event.pull_request.number }} --add-label "Changelog needed"
            echo "should_block=true" >> $GITHUB_OUTPUT
          else
            echo "User PR detected with changelog changes - allowing"
            echo "should_block=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  #################################################
  # CODE QUALITY CHECKS
  #################################################
  # For non-bot PRs - runs immediately
  quality-lint-format-user:
    needs: [initial-author-check-pr, initial-author-check-manual]
    if: |
      always() &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'false') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'false')
      )
    uses: ./.github/workflows/lint_format.yml
    with:
      job-name: 'üßπ Code Quality Checks'

  # For bot PRs - waits for changelog update to finish
  quality-lint-format-bot:
    # Wait for changelog update to complete for bot PRs
    needs: [initial-author-check-pr, initial-author-check-manual, changelog-update-dependabot]
    if: |
      always() &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'true') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'true')
      )
    uses: ./.github/workflows/lint_format.yml
    with:
      job-name: 'üßπ Code Quality Checks (Bot PR)'

  #################################################
  # PR METADATA CHECKS
  #################################################
  metadata-milestone-check:
    name: üè∑Ô∏è PR Milestone Check
    needs:
      - initial-author-check-pr
      - initial-author-check-manual
      - quality-lint-format-user
      - quality-lint-format-bot
    # This ensures it only needs one of the two lint jobs to complete based on PR author type
    if: ${{ always() && !contains(needs.*.result, 'cancelled') }}
    runs-on: ubuntu-latest
    steps:
      - name: Check if PR has milestone
        id: check-milestone
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;

            // Check if PR has a milestone
            const pr = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber
            });

            if (pr.data.milestone) {
              console.log(`PR #${prNumber} already has milestone: ${pr.data.milestone.title}`);
              return true;
            }

            // Get latest milestone
            const milestones = await github.rest.issues.listMilestones({
              owner,
              repo,
              state: 'open',
              sort: 'due_on',
              direction: 'desc'
            });

            if (milestones.data.length === 0) {
              console.log('No milestones found!');
              core.setFailed('No milestones available to add to PR');
              return false;
            }

            // Sort by creation date (newest first)
            const sortedMilestones = milestones.data.sort((a, b) => 
              new Date(b.created_at) - new Date(a.created_at)
            );

            const latestMilestone = sortedMilestones[0];
            console.log(`Latest milestone: ${latestMilestone.title}`);

            // Update the PR with the latest milestone
            await github.rest.issues.update({
              owner,
              repo,
              issue_number: prNumber,
              milestone: latestMilestone.number
            });

            // Add comment to PR
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: `‚úÖ Automatically added milestone ${latestMilestone.title} to this pull request.`
            });

            console.log(`Added milestone ${latestMilestone.title} to PR #${prNumber}`);
            return true;

  #################################################
  # FINAL STATUS CHECK
  #################################################
  final-status:
    name: üö¶ Final Status Check
    needs:
      - check-manual-trigger
      - initial-author-check-pr
      - initial-author-check-manual
      - quality-lint-format-user
      - quality-lint-format-bot
      - metadata-milestone-check
      - changelog-update-dependabot
      - changelog-check-user
      - changelog-enforce-user
    if: ${{ always() }}
    runs-on: ubuntu-latest
    steps:
      - name: Set job status variables
        id: set-status
        run: |
          # Determine if this is a bot PR regardless of trigger type
          IS_BOT_PR="false"
          IS_BOT_MANUAL="false"

          if [[ "${{ needs.initial-author-check-pr.result }}" == "success" ]]; then
            IS_BOT_PR="${{ needs.initial-author-check-pr.outputs.is_bot }}"
          fi

          if [[ "${{ needs.initial-author-check-manual.result }}" == "success" ]]; then
            IS_BOT_MANUAL="${{ needs.initial-author-check-manual.outputs.is_bot }}"
          fi

          # If either path determined it's a bot, set is_bot=true
          if [[ "$IS_BOT_PR" == "true" || "$IS_BOT_MANUAL" == "true" ]]; then
            echo "is_bot=true" >> $GITHUB_OUTPUT
          else
            echo "is_bot=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate status report
        run: |
          echo "## üìä PR Checks Status Report"
          echo ""
          echo "| Check | Status | Result |"
          echo "|-------|--------|--------|"

          # Check which trigger path was used
          if [[ "${{ needs.initial-author-check-pr.result }}" == "success" ]]; then
            echo "| üîç Initial Author Check (PR) | ${{ needs.initial-author-check-pr.result }} | PR is by ${{ needs.initial-author-check-pr.outputs.is_bot == 'true' && 'bot' || 'user' }} |"
          fi

          if [[ "${{ needs.initial-author-check-manual.result }}" == "success" ]]; then
            echo "| üîç Initial Author Check (Manual) | ${{ needs.initial-author-check-manual.result }} | PR is by ${{ needs.initial-author-check-manual.outputs.is_bot == 'true' && 'bot' || 'user' }} |"
          fi

          # Rest remains the same
          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            echo "| üìù Update Changelog (Bot) | ${{ needs.changelog-update-dependabot.result }} | ${{ needs.changelog-update-dependabot.outputs.changelog_updated == 'true' && 'Updated' || 'Not applicable' }} |"
            echo "| üßπ Code Quality (Bot) | ${{ needs.quality-lint-format-bot.result }} | - |"
          else
            echo "| üìã Check Changelog (User) | ${{ needs.changelog-check-user.result }} | Changes: ${{ needs.changelog-check-user.outputs.has_changes != '0' && 'Yes' || 'No' }} |"
            echo "| ‚úÖ Enforce Changelog | ${{ needs.changelog-enforce-user.result }} | Should block: ${{ needs.changelog-enforce-user.outputs.should_block }} |"
            echo "| üßπ Code Quality (User) | ${{ needs.quality-lint-format-user.result }} | - |"
          fi

          echo "| üè∑Ô∏è PR Milestone Check | ${{ needs.metadata-milestone-check.result }} | - |"

      # Split failure check to its own step with if condition
      - name: Check for job failures
        if: ${{ contains(needs.*.result, 'failure') }}
        run: |
          echo "‚õî One or more checks failed - blocking merge"

          # List which checks failed
          if [[ "${{ needs.initial-author-check-pr.result }}" == "failure" ]]; then
            echo "- ‚ùå Initial author check (PR) failed"
          fi

          if [[ "${{ needs.initial-author-check-manual.result }}" == "failure" ]]; then
            echo "- ‚ùå Initial author check (Manual) failed"
          fi

          if [[ "${{ needs.metadata-milestone-check.result }}" == "failure" ]]; then
            echo "- ‚ùå Milestone check failed"
          fi

          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            if [[ "${{ needs.quality-lint-format-bot.result }}" == "failure" ]]; then
              echo "- ‚ùå Code quality checks (bot) failed"
            fi
            if [[ "${{ needs.changelog-update-dependabot.result }}" == "failure" ]]; then
              echo "- ‚ùå Changelog update for bot failed"
            fi
          else
            if [[ "${{ needs.quality-lint-format-user.result }}" == "failure" ]]; then
              echo "- ‚ùå Code quality checks (user) failed"
            fi
            if [[ "${{ needs.changelog-check-user.result }}" == "failure" ]]; then
              echo "- ‚ùå Changelog check failed"
            fi
            if [[ "${{ needs.changelog-enforce-user.result }}" == "failure" ]]; then
              echo "- ‚ùå Changelog enforcement failed"
            fi
          fi

          exit 1

      - name: Check for skipped jobs (non-bot PR)
        if: ${{ steps.set-status.outputs.is_bot == 'false' }}
        env:
          QUALITY_STATUS: ${{ needs.quality-lint-format-user.result }}
          MILESTONE_STATUS: ${{ needs.metadata-milestone-check.result }}
        run: |
          if [[ "$QUALITY_STATUS" == "skipped" || "$MILESTONE_STATUS" == "skipped" ]]; then
            echo "‚ö†Ô∏è Required checks were skipped - blocking merge"
            
            if [[ "$QUALITY_STATUS" == "skipped" ]]; then
              echo "- ‚ö†Ô∏è Code quality checks were skipped"
            fi
            
            if [[ "$MILESTONE_STATUS" == "skipped" ]]; then
              echo "- ‚ö†Ô∏è Milestone checks were skipped"
            fi
            
            exit 1
          fi

      - name: Check for skipped jobs (bot PR)
        if: ${{ steps.set-status.outputs.is_bot == 'true' }}
        env:
          BOT_QUALITY_STATUS: ${{ needs.quality-lint-format-bot.result }}
          MILESTONE_STATUS: ${{ needs.metadata-milestone-check.result }}
        run: |
          if [[ "$BOT_QUALITY_STATUS" == "skipped" || "$MILESTONE_STATUS" == "skipped" ]]; then
            echo "‚ö†Ô∏è Required checks were skipped - blocking merge"
            
            if [[ "$BOT_QUALITY_STATUS" == "skipped" ]]; then
              echo "- ‚ö†Ô∏è Bot code quality checks were skipped"
            fi
            
            if [[ "$MILESTONE_STATUS" == "skipped" ]]; then
              echo "- ‚ö†Ô∏è Milestone checks were skipped"
            fi
            
            exit 1
          fi

      - name: Success message
        run: |
          echo "‚úÖ All PR checks completed successfully"

          # Provide a summary of what was run
          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            echo "Bot PR detected - ran bot-specific workflows"
            echo "- ‚úì Initial author check (completed)"
            echo "- ‚úì Bot code quality check (completed)"
            echo "- ‚úì Milestone check (completed)"
            if [[ "${{ needs.changelog-update-dependabot.result }}" != 'skipped' ]]; then
              echo "- ‚úì Changelog auto-update (completed)"
            fi
          else
            echo "User PR detected - ran user-specific workflows"
            echo "- ‚úì Initial author check (completed)"
            echo "- ‚úì User code quality check (completed)"
            echo "- ‚úì Milestone check (completed)"
            if [[ "${{ needs.changelog-check-user.result }}" != 'skipped' ]]; then
              echo "- ‚úì Changelog check (completed)"
            fi
          fi

      # Use GitHub API to explicitly report status (works better for Dependabot PRs)
      - name: Explicitly report final status
        if: ${{ always() }}
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;

            // Resolve PR number: prioritize manual trigger, fall back to PR event
            const prNumber = '${{ needs.check-manual-trigger.outputs.pr_number }}' || context.payload.pull_request?.number;

            const jobStatus = '${{ job.status }}';
            const isBot = '${{ steps.set-status.outputs.is_bot }}' === 'true';

            let sha;

            if (prNumber) {
              // Always get the latest commit SHA from the PR to handle mid-workflow commits
              try {
                console.log(`Fetching latest commit for PR #${prNumber}`);
                const prResponse = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: prNumber
                });
                
                sha = prResponse.data.head.sha;
                console.log(`Using latest PR head SHA: ${sha}`);
                
                // Log if this differs from the trigger SHA for debugging
                const triggerSha = context.payload.pull_request?.head?.sha || context.sha;
                if (sha !== triggerSha) {
                  console.log(`Note: Latest SHA (${sha}) differs from trigger SHA (${triggerSha})`);
                  console.log(`This typically means commits were made during workflow execution (e.g., changelog updates)`);
                }
              } catch (error) {
                console.error(`Error fetching PR details: ${error.message}`);
                // Fallback to trigger SHA
                sha = context.payload.pull_request?.head?.sha || context.sha;
                console.log(`Falling back to trigger SHA: ${sha}`);
              }
            } else {
              // No PR context, use event SHA
              sha = context.sha;
              console.log(`No PR context found, using event SHA: ${sha}`);
            }

            console.log(`Reporting final status for ${owner}/${repo}@${sha}: ${jobStatus}`);

            // Set state based on job status
            let state = 'success';
            let description = 'All PR checks completed successfully';

            if (jobStatus !== 'success') {
              state = 'failure';
              description = 'One or more PR checks failed';
            }

            try {
              // Explicitly create a status check for the Final Status Check
              // Note: Removed emoji from context to avoid 4-byte Unicode validation errors
              const statusResponse = await github.rest.repos.createCommitStatus({
                owner,
                repo,
                sha,
                state,
                description,
                context: 'Final Status Check'
              });
              
              console.log(`Status check created with state: ${state}, response status: ${statusResponse.status}`);
            } catch (error) {
              console.error(`Error creating status check: ${error.message}`);
              console.error(`Error details: ${JSON.stringify(error)}`);
              
              // Add a brief backoff before retry to reduce transient API race conditions
              console.log('Adding brief backoff (1 second) before retry...');
              await new Promise(resolve => setTimeout(resolve, 1000));
              
              // Try again with the current context SHA as fallback
              console.log(`Retrying with context SHA: ${context.sha}`);
              try {
                const fallbackResponse = await github.rest.repos.createCommitStatus({
                  owner,
                  repo,
                  sha: context.sha,
                  state,
                  description: description + " (fallback)",
                  context: 'Final Status Check'
                });
                console.log(`Fallback status check created with state: ${state}, response status: ${fallbackResponse.status}`);
              } catch (fallbackError) {
                console.error(`Error creating fallback status check: ${fallbackError.message}`);
                console.error(`Fallback error details: ${JSON.stringify(fallbackError)}`);
                
                // If both attempts fail, add additional logging for troubleshooting
                console.log('Both status creation attempts failed - this may require manual verification');
              }
            }

            // Exit with appropriate code using core.setFailed() for better consistency with GitHub Actions
            if (jobStatus !== 'success') {
              core.setFailed(`One or more PR checks failed with status: ${jobStatus}`);
            }

      # Post comprehensive PR comment with check results (update existing if found)
      - name: Comment on PR with results
        if: ${{ always() }}
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;

            // Resolve PR number: prioritize manual trigger, fall back to PR event
            const prNumber = '${{ needs.check-manual-trigger.outputs.pr_number }}' || context.payload.pull_request?.number;

            if (!prNumber) {
              console.log('No PR number found, skipping comment');
              return;
            }

            // Function to build comment content
            function buildCommentContent() {
              // Helper function to capitalize status values for display
              function capitalizeStatus(status) {
                if (!status) return status;
                return status.charAt(0).toUpperCase() + status.slice(1);
              }

              // Gather all job results and details
              const jobResults = {
                initialAuthorCheckPr: '${{ needs.initial-author-check-pr.result }}',
                initialAuthorCheckManual: '${{ needs.initial-author-check-manual.result }}',
                qualityLintFormatUser: '${{ needs.quality-lint-format-user.result }}',
                qualityLintFormatBot: '${{ needs.quality-lint-format-bot.result }}',
                metadataMilestoneCheck: '${{ needs.metadata-milestone-check.result }}',
                changelogUpdateDependabot: '${{ needs.changelog-update-dependabot.result }}',
                changelogCheckUser: '${{ needs.changelog-check-user.result }}',
                changelogEnforceUser: '${{ needs.changelog-enforce-user.result }}'
              };

              // Gather additional context
              const jobStatus = '${{ job.status }}';
              const isBot = '${{ steps.set-status.outputs.is_bot }}' === 'true';
              const isPrBot = '${{ needs.initial-author-check-pr.outputs.is_bot }}' === 'true';
              const isManualBot = '${{ needs.initial-author-check-manual.outputs.is_bot }}' === 'true';
              const changelogShouldBlock = '${{ needs.changelog-enforce-user.outputs.should_block }}' === 'true';
              const changelogHasChanges = '${{ needs.changelog-check-user.outputs.has_changes }}' !== '0';
              const changelogUpdated = '${{ needs.changelog-update-dependabot.outputs.changelog_updated }}' === 'true';

              // Determine final status
              const allPassed = jobStatus === 'success';

              // Build comment content with unique marker
              let content = `<!-- PR_CHECKS_BOT_COMMENT -->\n`;
              content += `## üö¶ PR Checks Summary\n\n`;
              content += `üîÑ **Last updated**: ${new Date().toISOString()}\n\n`;

              if (allPassed) {
                content += `‚úÖ **All checks have passed!** This PR is ready for review and merge.\n\n`;
              } else {
                content += `‚ùå **Some checks have failed.** Please review the details below and address any issues.\n\n`;
              }

              // Add detailed status table
              content += `### üìä Check Results\n\n`;
              content += `| Check | Status | Details |\n`;
              content += `|-------|--------|----------|\n`;

              // Author check results
              if (jobResults.initialAuthorCheckPr !== 'skipped') {
                const authorType = isPrBot ? 'Bot' : 'User';
                const statusIcon = jobResults.initialAuthorCheckPr === 'success' ? '‚úÖ' : '‚ùå';
                content += `| üîç Author Detection (PR) | ${statusIcon} ${capitalizeStatus(jobResults.initialAuthorCheckPr)} | Detected ${authorType} PR |\n`;
              }

              if (jobResults.initialAuthorCheckManual !== 'skipped') {
                const authorType = isManualBot ? 'Bot' : 'User';
                const statusIcon = jobResults.initialAuthorCheckManual === 'success' ? '‚úÖ' : '‚ùå';
                content += `| üîç Author Detection (Manual) | ${statusIcon} ${capitalizeStatus(jobResults.initialAuthorCheckManual)} | Detected ${authorType} PR |\n`;
              }

              // Code quality checks
              if (isBot && jobResults.qualityLintFormatBot !== 'skipped') {
                const statusIcon = jobResults.qualityLintFormatBot === 'success' ? '‚úÖ' : jobResults.qualityLintFormatBot === 'failure' ? '‚ùå' : '‚ö†Ô∏è';
                const details = jobResults.qualityLintFormatBot === 'failure' ? 'Linting or formatting issues found' : 'Code quality checks passed';
                content += `| üßπ Code Quality (Bot) | ${statusIcon} ${capitalizeStatus(jobResults.qualityLintFormatBot)} | ${details} |\n`;
              }

              if (!isBot && jobResults.qualityLintFormatUser !== 'skipped') {
                const statusIcon = jobResults.qualityLintFormatUser === 'success' ? '‚úÖ' : jobResults.qualityLintFormatUser === 'failure' ? '‚ùå' : '‚ö†Ô∏è';
                const details = jobResults.qualityLintFormatUser === 'failure' ? 'Linting or formatting issues found' : 'Code quality checks passed';
                content += `| üßπ Code Quality (User) | ${statusIcon} ${capitalizeStatus(jobResults.qualityLintFormatUser)} | ${details} |\n`;
              }

              // Changelog checks
              if (isBot && jobResults.changelogUpdateDependabot !== 'skipped') {
                const statusIcon = jobResults.changelogUpdateDependabot === 'success' ? '‚úÖ' : '‚ùå';
                const details = changelogUpdated ? 'Changelog automatically updated' : 'Changelog update failed or not applicable';
                content += `| üìù Changelog Update (Bot) | ${statusIcon} ${capitalizeStatus(jobResults.changelogUpdateDependabot)} | ${details} |\n`;
              }

              if (!isBot) {
                if (jobResults.changelogCheckUser !== 'skipped') {
                  const statusIcon = jobResults.changelogCheckUser === 'success' ? '‚úÖ' : '‚ùå';
                  const details = changelogHasChanges ? 'Changelog changes detected' : 'No changelog changes found';
                  content += `| üìã Changelog Check (User) | ${statusIcon} ${capitalizeStatus(jobResults.changelogCheckUser)} | ${details} |\n`;
                }
                
                if (jobResults.changelogEnforceUser !== 'skipped') {
                  const statusIcon = jobResults.changelogEnforceUser === 'success' ? '‚úÖ' : '‚ùå';
                  let details = 'Changelog requirement satisfied';
                  if (jobResults.changelogEnforceUser === 'failure' || changelogShouldBlock) {
                    details = 'Changelog update required - please update CHANGELOG.md';
                  }
                  content += `| ‚úÖ Changelog Enforcement | ${statusIcon} ${capitalizeStatus(jobResults.changelogEnforceUser)} | ${details} |\n`;
                }
              }

              // Milestone check
              if (jobResults.metadataMilestoneCheck !== 'skipped') {
                const statusIcon = jobResults.metadataMilestoneCheck === 'success' ? '‚úÖ' : '‚ùå';
                const details = jobResults.metadataMilestoneCheck === 'success' ? 'Milestone added or verified' : 'Failed to add milestone';
                content += `| üè∑Ô∏è Milestone Check | ${statusIcon} ${capitalizeStatus(jobResults.metadataMilestoneCheck)} | ${details} |\n`;
              }

              // Add failure details if any
              if (!allPassed) {
                content += `\n### ‚ùó Issues to Address\n\n`;
                
                const failures = [];
                const skippedRequired = [];

                // Check for actual failures
                Object.entries(jobResults).forEach(([job, result]) => {
                  if (result === 'failure') {
                    switch (job) {
                      case 'qualityLintFormatUser':
                      case 'qualityLintFormatBot':
                        failures.push('**Code Quality Issues**: Please fix linting or formatting errors. Run the lint and format commands locally to see specific issues.');
                        break;
                      case 'changelogEnforceUser':
                        if (changelogShouldBlock) {
                          failures.push('**Changelog Required**: Please update the `public/CHANGELOG.md` file with details about your changes.');
                        }
                        break;
                      case 'metadataMilestoneCheck':
                        failures.push('**Milestone Assignment**: Failed to automatically assign a milestone to this PR.');
                        break;
                      case 'changelogUpdateDependabot':
                        failures.push('**Changelog Update Failed**: Automatic changelog update for dependency changes failed.');
                        break;
                      case 'initialAuthorCheckPr':
                      case 'initialAuthorCheckManual':
                        failures.push('**Author Detection Failed**: Unable to determine if this is a bot or user PR.');
                        break;
                      default:
                        failures.push(`**${job}**: Check failed - please review the workflow logs for details.`);
                    }
                  } else if (result === 'skipped') {
                    // Only report skipped jobs that should have run
                    const isRequiredSkipped = (
                      (job === 'qualityLintFormatUser' && !isBot) ||
                      (job === 'qualityLintFormatBot' && isBot) ||
                      (job === 'metadataMilestoneCheck')
                    );
                    
                    if (isRequiredSkipped) {
                      skippedRequired.push(job);
                    }
                  }
                });

                // Add failure descriptions
                failures.forEach((failure, index) => {
                  content += `${index + 1}. ${failure}\n`;
                });

                // Add skipped required job warnings
                if (skippedRequired.length > 0) {
                  content += `\n‚ö†Ô∏è **Required checks were skipped**: Some necessary checks did not run, which may indicate a workflow configuration issue.\n`;
                }

                content += `\nüí° **Next Steps**: Please address the issues above and push new commits to re-trigger the checks.\n`;
              } else {
                content += `\nüéâ **Great job!** All automated checks have passed. Your PR is ready for human review.\n`;
              }

              // Add footer
              content += `\n---\n*This comment was automatically generated by the PR checks workflow.*`;
              
              return content;
            }

            try {
              // Search for existing bot comment with our marker
              console.log('Searching for existing PR checks comment...');
              const comments = await github.rest.issues.listComments({
                owner,
                repo,
                issue_number: prNumber
              });

              // Look for our comment by the hidden marker
              const botComment = comments.data.find(comment => 
                comment.body && comment.body.includes('<!-- PR_CHECKS_BOT_COMMENT -->')
              );

              const commentBody = buildCommentContent();

              if (botComment) {
                // Update existing comment
                console.log(`Updating existing comment (ID: ${botComment.id})`);
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: botComment.id,
                  body: commentBody
                });
                console.log('Existing PR comment updated successfully');
              } else {
                // Create new comment
                console.log('No existing comment found, creating new one');
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: commentBody
                });
                console.log('New PR comment created successfully');
              }
            } catch (commentError) {
              console.error(`Error managing PR comment: ${commentError.message}`);
              // Don't fail the workflow if commenting fails
            }
