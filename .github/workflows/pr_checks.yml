name: Pull Request Checks

on:
  pull_request:
    types: [opened, reopened, synchronize, edited, ready_for_review]
  issue_comment:
    types: [created]

# Add concurrency to cancel in-progress runs on new commits
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  statuses: write

jobs:
  #################################################
  # COMMENT CHECK - For manual trigger via !check
  #################################################
  check-manual-trigger:
    if: >
      github.event_name == 'issue_comment' && 
      github.event.issue.pull_request
    name: ðŸ” Check Manual Trigger
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check-command.outputs.should_run }}
      pr_number: ${{ steps.get-pr.outputs.pr_number }}
    steps:
      - uses: actions/checkout@v4.2.2

      - name: Load bot patterns
        id: load-patterns
        uses: ./.github/actions/load-bot-patterns

      - name: Check for command and owner
        id: check-command
        uses: actions/github-script@v7.0.1
        with:
          script: |
            ${{ steps.load-patterns.outputs.bot-patterns-script }}

            const comment = context.payload.comment.body;
            const commenter = context.payload.comment.user.login;

            // Use the centralized bot detection function
            const isBotCommenter = isBot(commenter);

            if (isBotCommenter) {
              console.log(`Ignoring comment from known bot account: ${commenter}`);
              core.setOutput('should_run', 'false');
              return;
            }

            // Check if the comment contains the command and is from repo owner
            // More strict matching: must be at beginning of line and a standalone word
            const isCommand = /^!check\b/.test(comment.trim());
            const isRepoOwner = context.payload.repository.owner.login === commenter;

            const shouldRun = isCommand && isRepoOwner;

            console.log(`Comment: "${comment}"`);
            console.log(`Commenter: ${commenter}`);
            console.log(`Is Owner: ${isRepoOwner}`);
            console.log(`Is Command: ${isCommand}`);
            console.log(`Should Run: ${shouldRun}`);

            core.setOutput('should_run', shouldRun.toString());

            // Comment with acknowledgment if it's the command
            if (isCommand) {
              if (isRepoOwner) {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: 'âœ… PR check workflow manually triggered by repository owner.'
                });
              } else {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: 'âš ï¸ Only repository owners can trigger the PR check workflow manually.'
                });
              }
            }

      - name: Get PR number
        id: get-pr
        if: ${{ steps.check-command.outputs.should_run == 'true' }}
        uses: actions/github-script@v7.0.1
        with:
          script: |
            // Comment is on a PR issue
            const prNumber = context.issue.number;
            console.log(`PR Number: ${prNumber}`);
            core.setOutput('pr_number', prNumber);

  #################################################
  # INITIAL CHECK - Author detection for PR events
  #################################################
  initial-author-check-pr:
    if: ${{ github.event_name == 'pull_request' }}
    name: ðŸ” Initial PR Author Check
    uses: ./.github/workflows/check_bot_author.yml
    with:
      pr_number: ${{ github.event.pull_request.number }}
      event_type: 'pull_request'

  #################################################
  # INITIAL CHECK - Author detection for manual triggers
  #################################################
  initial-author-check-manual:
    needs: [check-manual-trigger]
    if: ${{ github.event_name == 'issue_comment' && needs.check-manual-trigger.outputs.should_run == 'true' }}
    name: ðŸ” Initial PR Author Check (Manual)
    uses: ./.github/workflows/check_bot_author.yml
    with:
      pr_number: ${{ needs.check-manual-trigger.outputs.pr_number }}
      event_type: 'issue_comment'

  #################################################
  # EARLY EXIT - Stop workflow for excluded bots
  #################################################
  early-exit-excluded-bots:
    name: ðŸš« Early Exit for Excluded Bots
    needs: [initial-author-check-pr, initial-author-check-manual]
    if: |
      always() &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_excluded_bot == 'true') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_excluded_bot == 'true')
      )
    runs-on: ubuntu-latest
    steps:
      - name: Skip workflow for excluded bot
        run: |
          echo "ðŸ¤– Excluded bot detected - skipping all PR checks"
          echo "This workflow has been designed to skip checks for certain automated bots"
          echo "to avoid unnecessary resource usage and workflow noise."

          # Determine which bot was detected
          if [[ "${{ needs.initial-author-check-pr.outputs.is_excluded_bot }}" == "true" ]]; then
            echo "Bot detected via PR event"
          elif [[ "${{ needs.initial-author-check-manual.outputs.is_excluded_bot }}" == "true" ]]; then
            echo "Bot detected via manual trigger"
          fi

          echo "âœ… Workflow completed successfully (excluded bot path)"

  #################################################
  # CHANGELOG CHECKS
  #################################################
  changelog-update-dependabot:
    name: ðŸ“ Update Changelog (Dependabot)
    needs: [initial-author-check-pr, initial-author-check-manual, early-exit-excluded-bots]
    if: |
      always() &&
      needs.early-exit-excluded-bots.result == 'skipped' &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_dependabot == 'true') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_dependabot == 'true')
      )
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    outputs:
      changelog_updated: ${{ steps.extract-info.outputs.has_match }}
      package_name: ${{ steps.extract-info.outputs.package }}
      from_version: ${{ steps.extract-info.outputs.from_version }}
      to_version: ${{ steps.extract-info.outputs.to_version }}
      dep_type: ${{ steps.update-changelog.outputs.dep_type }}
      commit_sha: ${{ steps.update-changelog.outputs.commit_sha }}
    steps:
      - uses: actions/checkout@v4.2.2
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Extract dependency information
        id: extract-info
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          # Pattern for conventional commit format: build(deps): bump package from version to version
          if [[ "$PR_TITLE" =~ build\(deps.*\):\ bump\ ([^\ ]+)\ from\ ([0-9]+[\.0-9]*)\ to\ ([0-9]+[\.0-9]*) ]]; then
            PACKAGE="${BASH_REMATCH[1]}"
            FROM_VERSION="${BASH_REMATCH[2]}"
            TO_VERSION="${BASH_REMATCH[3]}"
            echo "package=$PACKAGE" >> $GITHUB_OUTPUT
            echo "from_version=$FROM_VERSION" >> $GITHUB_OUTPUT
            echo "to_version=$TO_VERSION" >> $GITHUB_OUTPUT
            echo "has_match=true" >> $GITHUB_OUTPUT
          else
            echo "has_match=false" >> $GITHUB_OUTPUT
          fi

      - name: Update CHANGELOG.md
        id: update-changelog
        if: steps.extract-info.outputs.has_match == 'true'
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          CHANGELOG_FILE="public/CHANGELOG.md"
          PACKAGE="${{ steps.extract-info.outputs.package }}"
          FROM_VERSION="${{ steps.extract-info.outputs.from_version }}"
          TO_VERSION="${{ steps.extract-info.outputs.to_version }}"

          if [ ! -f "$CHANGELOG_FILE" ]; then
            echo "::error::CHANGELOG.md not found at $CHANGELOG_FILE"
            echo "Error: CHANGELOG.md not found at $CHANGELOG_FILE"
            exit 1
          fi

          # Determine the type of dependency
          DEP_TYPE="dependency"
          if [[ "$PR_TITLE" == *"deps-dev"* ]]; then
            DEP_TYPE="dev dependency"
          fi
          echo "dep_type=$DEP_TYPE" >> $GITHUB_OUTPUT

          # Find the first version section line and the next section (if any)
          FIRST_VERSION_LINE=$(grep -n "^## " "$CHANGELOG_FILE" | head -1 | cut -d: -f1)
          NEXT_VERSION_LINE=$(grep -n "^---" "$CHANGELOG_FILE" | head -1 | cut -d: -f1)

          # If there's no next section (no "---" line found), insert before the end of the file
          if [ -z "$NEXT_VERSION_LINE" ]; then
            INSERT_LINE="$(($(wc -l < "$CHANGELOG_FILE")+1))"
          else
            # Insert right before the "---" separator
            INSERT_LINE="$((NEXT_VERSION_LINE-1))"
          fi

          # Format the changelog entry
          ENTRY="- Bump $DEP_TYPE \`$PACKAGE\` from $FROM_VERSION to $TO_VERSION"

          # Insert the entry before the separator line or at the end of file
          sed -i "${INSERT_LINE}i $ENTRY" "$CHANGELOG_FILE"

          # Commit and push the changes
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          git add "$CHANGELOG_FILE"
          git commit -m "docs: update changelog with $PACKAGE dependency bump"
          git push

          # Get the commit SHA of the new commit we just pushed
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "Updated changelog with commit: $COMMIT_SHA"

      - name: Comment on PR about changelog update
        if: steps.extract-info.outputs.has_match == 'true'
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const packageName = '${{ steps.extract-info.outputs.package }}';
            const fromVersion = '${{ steps.extract-info.outputs.from_version }}';
            const toVersion = '${{ steps.extract-info.outputs.to_version }}';
            const depType = '${{ steps.update-changelog.outputs.dep_type }}';

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸ“ **Changelog Automatically Updated**\n\nA changelog entry has been automatically added for this Dependabot PR:\n\n- Bump ${depType} ${packageName} from ${fromVersion} to ${toVersion}`
            });

  changelog-check-user:
    name: ðŸ“‹ Check Changelog (User PR)
    needs: [initial-author-check-pr, initial-author-check-manual, early-exit-excluded-bots]
    if: |
      always() &&
      needs.early-exit-excluded-bots.result == 'skipped' &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'false') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'false')
      )
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.changelog-check.outputs.changed }}
    steps:
      - uses: actions/checkout@v4.2.2
      - name: Check for changelog changes
        id: changelog-check
        run: |
          git fetch origin ${{ github.base_ref }} --depth=1
          CHANGELOG_CHANGED=$(git diff --name-only origin/${{ github.base_ref }} | grep -c "public/CHANGELOG.md" || true)
          echo "changed=$CHANGELOG_CHANGED" >> $GITHUB_OUTPUT

  changelog-enforce-user:
    name: âœ… Enforce Changelog (User PR)
    needs:
      [
        initial-author-check-pr,
        initial-author-check-manual,
        early-exit-excluded-bots,
        changelog-check-user,
      ]
    if: |
      always() &&
      needs.early-exit-excluded-bots.result == 'skipped' &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'false') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'false')
      )
    runs-on: ubuntu-latest
    outputs:
      should_block: ${{ steps.check-status.outputs.should_block }}
    steps:
      - uses: actions/checkout@v4.2.2

      - name: Handle changelog enforcement
        id: check-status
        run: |
          HAS_CHANGES="${{ needs.changelog-check-user.outputs.has_changes }}"

          # Always try to remove the label first if changes exist
          if [[ "$HAS_CHANGES" != "0" ]]; then
            echo "Changelog changes detected - removing label if it exists"
            gh pr edit ${{ github.event.pull_request.number }} --remove-label "Changelog needed" 2>/dev/null || true
          fi

          # For non-bot PRs, check if changelog was updated
          if [[ "$HAS_CHANGES" == "0" ]]; then
            echo "::error::Changelog update is required for this PR"
            echo "User PR detected without changelog changes - blocking"
            gh label create "Changelog needed" --color FF0000 --description "Changelog update required" 2>/dev/null || true
            gh pr edit ${{ github.event.pull_request.number }} --add-label "Changelog needed"
            echo "should_block=true" >> $GITHUB_OUTPUT
            echo "âŒ Changelog update is required for this PR"
            # Set step failure but don't exit to preserve outputs
            echo "::error::Changelog update is required - job will fail but outputs are preserved"
          else
            echo "User PR detected with changelog changes - allowing"
            echo "should_block=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Fail job if changelog update required
        if: steps.check-status.outputs.should_block == 'true'
        run: |
          echo "::error::Changelog update is required for this PR"
          exit 1

  #################################################
  # CODE QUALITY CHECKS
  #################################################
  # For non-bot PRs - runs immediately
  quality-lint-format-user:
    needs: [initial-author-check-pr, initial-author-check-manual, early-exit-excluded-bots]
    if: |
      always() &&
      needs.early-exit-excluded-bots.result == 'skipped' &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'false') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'false')
      )
    uses: ./.github/workflows/lint_format.yml
    with:
      job-name: 'ðŸ§¹ Code Quality Checks'

  # For bot PRs - waits for changelog update to finish
  quality-lint-format-bot:
    # Wait for changelog update to complete for bot PRs
    needs:
      [
        initial-author-check-pr,
        initial-author-check-manual,
        early-exit-excluded-bots,
        changelog-update-dependabot,
      ]
    if: |
      always() &&
      needs.early-exit-excluded-bots.result == 'skipped' &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'true') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'true')
      )
    uses: ./.github/workflows/lint_format.yml
    with:
      job-name: 'ðŸ§¹ Code Quality Checks (Bot PR)'

  #################################################
  # PR METADATA CHECKS
  #################################################
  metadata-milestone-check:
    name: ðŸ·ï¸ PR Milestone Check
    needs:
      - initial-author-check-pr
      - initial-author-check-manual
      - early-exit-excluded-bots
      - quality-lint-format-user
      - quality-lint-format-bot
    # This ensures it only needs one of the two lint jobs to complete based on PR author type
    if: ${{ always() && needs.early-exit-excluded-bots.result == 'skipped' && !contains(needs.*.result, 'cancelled') }}
    runs-on: ubuntu-latest
    steps:
      - name: Check if PR has milestone
        id: check-milestone
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;

            // Check if PR has a milestone
            const pr = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber
            });

            if (pr.data.milestone) {
              console.log(`PR #${prNumber} already has milestone: ${pr.data.milestone.title}`);
              return true;
            }

            // Get latest milestone
            const milestones = await github.rest.issues.listMilestones({
              owner,
              repo,
              state: 'open',
              sort: 'due_on',
              direction: 'desc'
            });

            if (milestones.data.length === 0) {
              console.log('No milestones found!');
              core.setFailed('No milestones available to add to PR');
              return false;
            }

            // Sort by creation date (newest first)
            const sortedMilestones = milestones.data.sort((a, b) => 
              new Date(b.created_at) - new Date(a.created_at)
            );

            const latestMilestone = sortedMilestones[0];
            console.log(`Latest milestone: ${latestMilestone.title}`);

            // Update the PR with the latest milestone
            await github.rest.issues.update({
              owner,
              repo,
              issue_number: prNumber,
              milestone: latestMilestone.number
            });

            // Add comment to PR
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: `âœ… Automatically added milestone ${latestMilestone.title} to this pull request.`
            });

            console.log(`Added milestone ${latestMilestone.title} to PR #${prNumber}`);
            return true;

  #################################################
  # FINAL STATUS CHECK
  #################################################
  final-status:
    name: ðŸš¦ Final Status Check
    needs:
      - check-manual-trigger
      - initial-author-check-pr
      - initial-author-check-manual
      - early-exit-excluded-bots
      - quality-lint-format-user
      - quality-lint-format-bot
      - metadata-milestone-check
      - changelog-update-dependabot
      - changelog-check-user
      - changelog-enforce-user
    if: ${{ always() }}
    runs-on: ubuntu-latest
    steps:
      - name: Check for excluded bot early exit
        id: check-excluded-bot
        run: |
          # Check if this was an excluded bot that triggered early exit
          if [[ "${{ needs.early-exit-excluded-bots.result }}" == "success" ]]; then
            echo "excluded_bot_detected=true" >> $GITHUB_OUTPUT
            echo "ðŸ¤– Excluded bot detected - workflow completed via early exit path"
            echo "This is the expected behavior for CodeRabbit AI, Vercel, and similar bots."
          else
            echo "excluded_bot_detected=false" >> $GITHUB_OUTPUT
          fi

      - name: Set job status variables
        id: set-status
        run: |
          # Determine if this is a bot PR regardless of trigger type
          IS_BOT_PR="false"
          IS_BOT_MANUAL="false"

          if [[ "${{ needs.initial-author-check-pr.result }}" == "success" ]]; then
            IS_BOT_PR="${{ needs.initial-author-check-pr.outputs.is_bot }}"
          fi

          if [[ "${{ needs.initial-author-check-manual.result }}" == "success" ]]; then
            IS_BOT_MANUAL="${{ needs.initial-author-check-manual.outputs.is_bot }}"
          fi

          # If either path determined it's a bot, set is_bot=true
          if [[ "$IS_BOT_PR" == "true" || "$IS_BOT_MANUAL" == "true" ]]; then
            echo "is_bot=true" >> $GITHUB_OUTPUT
          else
            echo "is_bot=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate status report
        run: |
          # If excluded bot was detected, show simplified success message
          if [[ "${{ steps.check-excluded-bot.outputs.excluded_bot_detected }}" == "true" ]]; then
            echo "## ðŸ¤– Excluded Bot Detected"
            echo ""
            echo "This PR is from an excluded bot (CodeRabbit AI, Vercel, etc.)."
            echo "All PR checks have been automatically skipped to avoid unnecessary workflow runs."
            echo ""
            echo "âœ… **Status: Completed Successfully (Excluded Bot Path)**"
            echo ""
            echo "| Check | Status | Result |"
            echo "|-------|--------|--------|"
            echo "| ðŸ” Bot Detection | âœ… Success | Excluded bot detected |"
            echo "| ðŸš« Early Exit | âœ… Success | Workflow skipped appropriately |"
            exit 0
          fi

          echo "## ðŸ“Š PR Checks Status Report"
          echo ""
          echo "| Check | Status | Result |"
          echo "|-------|--------|--------|"

          # Check which trigger path was used
          if [[ "${{ needs.initial-author-check-pr.result }}" == "success" ]]; then
            echo "| ðŸ” Initial Author Check (PR) | ${{ needs.initial-author-check-pr.result }} | PR is by ${{ needs.initial-author-check-pr.outputs.is_bot == 'true' && 'bot' || 'user' }} |"
          fi

          if [[ "${{ needs.initial-author-check-manual.result }}" == "success" ]]; then
            echo "| ðŸ” Initial Author Check (Manual) | ${{ needs.initial-author-check-manual.result }} | PR is by ${{ needs.initial-author-check-manual.outputs.is_bot == 'true' && 'bot' || 'user' }} |"
          fi

          # Rest remains the same
          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            echo "| ðŸ“ Update Changelog (Bot) | ${{ needs.changelog-update-dependabot.result }} | ${{ needs.changelog-update-dependabot.outputs.changelog_updated == 'true' && 'Updated' || 'Not applicable' }} |"
            echo "| ðŸ§¹ Code Quality (Bot) | ${{ needs.quality-lint-format-bot.result }} | - |"
          else
            echo "| ðŸ“‹ Check Changelog (User) | ${{ needs.changelog-check-user.result }} | Changes: ${{ needs.changelog-check-user.outputs.has_changes != '0' && 'Yes' || 'No' }} |"
            echo "| âœ… Enforce Changelog | ${{ needs.changelog-enforce-user.result }} | ${{ needs.changelog-enforce-user.result == 'failure' && 'Changelog update required' || 'Satisfied' }} |"
            echo "| ðŸ§¹ Code Quality (User) | ${{ needs.quality-lint-format-user.result }} | - |"
          fi

          echo "| ðŸ·ï¸ PR Milestone Check | ${{ needs.metadata-milestone-check.result }} | - |"

      # Split failure check to its own step with if condition
      - name: Check for job failures
        if: ${{ contains(needs.*.result, 'failure') && steps.check-excluded-bot.outputs.excluded_bot_detected != 'true' }}
        run: |
          echo "â›” One or more checks failed - blocking merge"

          # List which checks failed
          if [[ "${{ needs.initial-author-check-pr.result }}" == "failure" ]]; then
            echo "- âŒ Initial author check (PR) failed"
          fi

          if [[ "${{ needs.initial-author-check-manual.result }}" == "failure" ]]; then
            echo "- âŒ Initial author check (Manual) failed"
          fi

          if [[ "${{ needs.metadata-milestone-check.result }}" == "failure" ]]; then
            echo "- âŒ Milestone check failed"
          fi

          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            if [[ "${{ needs.quality-lint-format-bot.result }}" == "failure" ]]; then
              echo "- âŒ Code quality checks (bot) failed"
            fi
            if [[ "${{ needs.changelog-update-dependabot.result }}" == "failure" ]]; then
              echo "- âŒ Changelog update for bot failed"
            fi
          else
            if [[ "${{ needs.quality-lint-format-user.result }}" == "failure" ]]; then
              echo "- âŒ Code quality checks (user) failed"
            fi
            if [[ "${{ needs.changelog-check-user.result }}" == "failure" ]]; then
              echo "- âŒ Changelog check failed"
            fi
            if [[ "${{ needs.changelog-enforce-user.result }}" == "failure" ]]; then
            echo "- âŒ Changelog enforcement failed - changelog update required"
          fi
          fi

          echo "::error::One or more checks failed - blocking merge"
          exit 1

      - name: Check for skipped jobs
        if: ${{ steps.check-excluded-bot.outputs.excluded_bot_detected != 'true' }}
        env:
          USER_QUALITY_STATUS: ${{ needs.quality-lint-format-user.result }}
          BOT_QUALITY_STATUS: ${{ needs.quality-lint-format-bot.result }}
          MILESTONE_STATUS: ${{ needs.metadata-milestone-check.result }}
          IS_BOT: ${{ steps.set-status.outputs.is_bot }}
        run: |
          # Function to check for skipped jobs and report errors
          check_skipped_jobs() {
            local quality_status="$1"
            local quality_label="$2"
            local milestone_status="$3"
            
            if [[ "$quality_status" == "skipped" || "$milestone_status" == "skipped" ]]; then
              echo "::error::Required checks were skipped - blocking merge"
              echo "âš ï¸ Required checks were skipped - blocking merge"
              
              if [[ "$quality_status" == "skipped" ]]; then
                echo "- âš ï¸ $quality_label were skipped"
              fi
              
              if [[ "$milestone_status" == "skipped" ]]; then
                echo "- âš ï¸ Milestone checks were skipped"
              fi
              
              exit 1
            fi
          }

          # Check based on PR type
          if [[ "$IS_BOT" == "true" ]]; then
            check_skipped_jobs "$BOT_QUALITY_STATUS" "Bot code quality checks" "$MILESTONE_STATUS"
          else
            check_skipped_jobs "$USER_QUALITY_STATUS" "Code quality checks" "$MILESTONE_STATUS"
          fi

      - name: Success message
        if: ${{ steps.check-excluded-bot.outputs.excluded_bot_detected != 'true' }}
        run: |
          echo "âœ… All PR checks completed successfully"

          # Provide a summary of what was run
          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            echo "Bot PR detected - ran bot-specific workflows"
            echo "- âœ“ Initial author check (completed)"
            echo "- âœ“ Bot code quality check (completed)"
            echo "- âœ“ Milestone check (completed)"
            if [[ "${{ needs.changelog-update-dependabot.result }}" != 'skipped' ]]; then
              echo "- âœ“ Changelog auto-update (completed)"
            fi
          else
            echo "User PR detected - ran user-specific workflows"
            echo "- âœ“ Initial author check (completed)"
            echo "- âœ“ User code quality check (completed)"
            echo "- âœ“ Milestone check (completed)"
            if [[ "${{ needs.changelog-check-user.result }}" != 'skipped' ]]; then
              echo "- âœ“ Changelog check (completed)"
            fi
          fi

      - name: Success message for excluded bots
        if: ${{ steps.check-excluded-bot.outputs.excluded_bot_detected == 'true' }}
        run: |
          echo "âœ… Excluded bot workflow completed successfully"
          echo ""
          echo "ðŸ¤– This PR is from an excluded bot, so all checks were appropriately skipped."
          echo "This is the expected and desired behavior to avoid unnecessary resource usage."

      # Auto-assign PR based on check results
      - name: Auto-assign PR based on results
        if: ${{ always() && steps.check-excluded-bot.outputs.excluded_bot_detected != 'true' }}
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;

            // Resolve PR number: prioritize manual trigger, fall back to PR event
            const manualTriggerPR = '${{ needs.check-manual-trigger.outputs.pr_number }}';
            const prNumber = (manualTriggerPR && !isNaN(Number(manualTriggerPR))) 
              ? Number(manualTriggerPR) 
              : context.payload.pull_request?.number;

            if (!prNumber) {
              console.log('No PR number found, skipping assignment');
              return;
            }

            const jobStatus = '${{ job.status }}';
            const allPassed = jobStatus === 'success';

            try {
              // Get PR details including current assignees and author
              const prResponse = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber
              });

              const prAuthor = prResponse.data.user.login;
              const currentAssignees = prResponse.data.assignees.map(assignee => assignee.login);
              const repoOwnerLogin = context.payload.repository.owner.login;

              // Check if the repository owner is an organization
              let repoOwnerUser = null;
              let isOrganization = false;

              try {
                const ownerResponse = await github.rest.users.getByUsername({
                  username: repoOwnerLogin
                });
                isOrganization = ownerResponse.data.type === 'Organization';
                console.log(`Repository owner ${repoOwnerLogin} is ${isOrganization ? 'an organization' : 'a user'}`);
              } catch (ownerError) {
                console.log(`Could not determine owner type for ${repoOwnerLogin}: ${ownerError.message}`);
                // Assume it's a user if we can't determine
                isOrganization = false;
              }

              let targetAssignee;
              let assignmentReason;

              if (allPassed) {
                if (isOrganization) {
                  // For organization repos, assign to PR author since orgs can't be assigned
                  targetAssignee = prAuthor;
                  assignmentReason = 'All checks passed - assigned to PR author (org-owned repo)';
                  console.log(`Repository is owned by organization ${repoOwnerLogin}, assigning to PR author instead`);
                } else {
                  // For user repos, assign to repo owner for review
                  targetAssignee = repoOwnerLogin;
                  assignmentReason = 'All checks passed - ready for owner review';
                }
              } else {
                // Some checks failed or had warnings - assign to PR author
                targetAssignee = prAuthor;
                assignmentReason = 'Checks failed or have warnings - needs author attention';
              }

              // Check if the target assignee is already assigned
              if (currentAssignees.includes(targetAssignee)) {
                console.log(`PR is already assigned to ${targetAssignee}, no change needed`);
                return;
              }

              // Assign the PR to the target user
              console.log(`Assigning PR #${prNumber} to ${targetAssignee} (${assignmentReason})`);
              
              await github.rest.issues.addAssignees({
                owner,
                repo,
                issue_number: prNumber,
                assignees: [targetAssignee]
              });

              // Remove other assignees if needed (optional - keeps assignment clean)
              const assigneesToRemove = currentAssignees.filter(assignee => assignee !== targetAssignee);
              if (assigneesToRemove.length > 0) {
                console.log(`Removing previous assignees: ${assigneesToRemove.join(', ')}`);
                await github.rest.issues.removeAssignees({
                  owner,
                  repo,
                  issue_number: prNumber,
                  assignees: assigneesToRemove
                });
              }

              console.log(`Successfully assigned PR #${prNumber} to ${targetAssignee}`);

              // Add a comment about the assignment with organization-aware messaging
              let assignmentComment;
              if (allPassed) {
                if (isOrganization) {
                  assignmentComment = `ðŸŽ¯ **Auto-assigned to @${targetAssignee}** - All checks passed! This PR is ready for review and merge. (Note: Assigned to PR author since repository is organization-owned)`;
                } else {
                  assignmentComment = `ðŸŽ¯ **Auto-assigned to @${targetAssignee}** - All checks passed! This PR is ready for review and merge.`;
                }
              } else {
                assignmentComment = `ðŸŽ¯ **Auto-assigned to @${targetAssignee}** - Please address the failed checks and push new commits to re-trigger the workflow.`;
              }

              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: prNumber,
                body: assignmentComment
              });

            } catch (error) {
              console.error(`Error auto-assigning PR: ${error.message}`);
              
              // Provide more detailed error information
              if (error.message.includes('Validation Failed')) {
                console.error('Assignment validation failed - this often happens when trying to assign organizations or invalid users');
                console.error('Full error details:', JSON.stringify(error.response?.data || error, null, 2));
              }
              
              // Don't fail the workflow if assignment fails
              console.log('Assignment failed but workflow will continue');
              
              // Try to add a comment explaining the assignment failure
              try {
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: `âš ï¸ **Auto-assignment failed** - Could not automatically assign this PR. Please manually assign as needed.`
                });
              } catch (commentError) {
                console.error(`Could not add comment about assignment failure: ${commentError.message}`);
              }
            }
      # Use GitHub API to explicitly report status (works better for Dependabot PRs)
      - name: Explicitly report final status
        if: ${{ always() }}
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;

            // Check if this was an excluded bot
            const isExcludedBot = '${{ steps.check-excluded-bot.outputs.excluded_bot_detected }}' === 'true';

            if (isExcludedBot) {
              console.log('Excluded bot detected - skipping status reporting to avoid noise');
              console.log('This is the expected behavior for CodeRabbit AI, Vercel, and similar bots');
              return;
            }

            // Resolve PR number: prioritize manual trigger, fall back to PR event
            const manualTriggerPR = '${{ needs.check-manual-trigger.outputs.pr_number }}';
            const prNumber = (manualTriggerPR && !isNaN(Number(manualTriggerPR))) 
              ? Number(manualTriggerPR) 
              : context.payload.pull_request?.number;

            const jobStatus = '${{ job.status }}';
            const isBot = '${{ steps.set-status.outputs.is_bot }}' === 'true';

            let sha;

            if (prNumber) {
              // Always get the latest commit SHA from the PR to handle mid-workflow commits
              try {
                console.log(`Fetching latest commit for PR #${prNumber}`);
                const prResponse = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: prNumber
                });
                
                sha = prResponse.data.head.sha;
                console.log(`Using latest PR head SHA: ${sha}`);
                
                // Log if this differs from the trigger SHA for debugging
                const triggerSha = context.payload.pull_request?.head?.sha || context.sha;
                if (sha !== triggerSha) {
                  console.log(`Note: Latest SHA (${sha}) differs from trigger SHA (${triggerSha})`);
                  console.log(`This typically means commits were made during workflow execution (e.g., changelog updates)`);
                }
              } catch (error) {
                console.error(`Error fetching PR details: ${error.message}`);
                // Fallback to trigger SHA
                sha = context.payload.pull_request?.head?.sha || context.sha;
                console.log(`Falling back to trigger SHA: ${sha}`);
              }
            } else {
              // No PR context, use event SHA
              sha = context.sha;
              console.log(`No PR context found, using event SHA: ${sha}`);
            }

            console.log(`Reporting final status for ${owner}/${repo}@${sha}: ${jobStatus}`);

            // Set state based on job status
            let state = 'success';
            let description = 'All PR checks completed successfully';

            if (jobStatus !== 'success') {
              state = 'failure';
              description = 'One or more PR checks failed';
            }

            try {
              // Explicitly create a status check for the Final Status Check
              // Note: Removed emoji from context to avoid 4-byte Unicode validation errors
              const statusResponse = await github.rest.repos.createCommitStatus({
                owner,
                repo,
                sha,
                state,
                description,
                context: 'Final Status Check'
              });
              
              console.log(`Status check created with state: ${state}, response status: ${statusResponse.status}`);
            } catch (error) {
              console.error(`Error creating status check: ${error.message}`);
              console.error(`Error details: ${JSON.stringify(error)}`);
              
              // Add a brief backoff before retry to reduce transient API race conditions
              console.log('Adding brief backoff (1 second) before retry...');
              await new Promise(resolve => setTimeout(resolve, 1000));
              
              // Try again with the current context SHA as fallback
              console.log(`Retrying with context SHA: ${context.sha}`);
              try {
                const fallbackResponse = await github.rest.repos.createCommitStatus({
                  owner,
                  repo,
                  sha: context.sha,
                  state,
                  description: description + " (fallback)",
                  context: 'Final Status Check'
                });
                console.log(`Fallback status check created with state: ${state}, response status: ${fallbackResponse.status}`);
              } catch (fallbackError) {
                console.error(`Error creating fallback status check: ${fallbackError.message}`);
                console.error(`Fallback error details: ${JSON.stringify(fallbackError)}`);
                
                // If both attempts fail, add additional logging for troubleshooting
                console.log('Both status creation attempts failed - this may require manual verification');
              }
            }

            // Exit with appropriate code using core.setFailed() for better consistency with GitHub Actions
            if (jobStatus !== 'success') {
              core.setFailed(`One or more PR checks failed with status: ${jobStatus}`);
            }

      # Post comprehensive PR comment with check results (update existing if found)
      - name: Comment on PR with results
        if: ${{ always() && steps.check-excluded-bot.outputs.excluded_bot_detected != 'true' }}
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;

            // Resolve PR number: prioritize manual trigger, fall back to PR event
            const manualTriggerPR = '${{ needs.check-manual-trigger.outputs.pr_number }}';
            const prNumber = (manualTriggerPR && !isNaN(Number(manualTriggerPR))) 
              ? Number(manualTriggerPR) 
              : context.payload.pull_request?.number;

            if (!prNumber) {
              console.log('No PR number found, skipping comment');
              return;
            }

            // Function to build comment content
            function buildCommentContent() {
              // Helper function to capitalize status values for display
              function capitalizeStatus(status) {
                if (!status) return status;
                return status.charAt(0).toUpperCase() + status.slice(1);
              }

              // Gather all job results and details
              const jobResults = {
                initialAuthorCheckPr: '${{ needs.initial-author-check-pr.result }}',
                initialAuthorCheckManual: '${{ needs.initial-author-check-manual.result }}',
                qualityLintFormatUser: '${{ needs.quality-lint-format-user.result }}',
                qualityLintFormatBot: '${{ needs.quality-lint-format-bot.result }}',
                metadataMilestoneCheck: '${{ needs.metadata-milestone-check.result }}',
                changelogUpdateDependabot: '${{ needs.changelog-update-dependabot.result }}',
                changelogCheckUser: '${{ needs.changelog-check-user.result }}',
                changelogEnforceUser: '${{ needs.changelog-enforce-user.result }}'
              };

              // Gather additional context
              const jobStatus = '${{ job.status }}';
              const isBot = '${{ steps.set-status.outputs.is_bot }}' === 'true';
              const isPrBot = '${{ needs.initial-author-check-pr.outputs.is_bot }}' === 'true';
              const isManualBot = '${{ needs.initial-author-check-manual.outputs.is_bot }}' === 'true';
              const changelogShouldBlock = '${{ needs.changelog-enforce-user.outputs.should_block }}' === 'true';
              const changelogHasChanges = '${{ needs.changelog-check-user.outputs.has_changes }}' !== '0';
              const changelogUpdated = '${{ needs.changelog-update-dependabot.outputs.changelog_updated }}' === 'true';

              // Determine final status
              const allPassed = jobStatus === 'success';

              // Build comment content with unique marker
              let content = `<!-- PR_CHECKS_BOT_COMMENT -->\n`;
              content += `## ðŸš¦ PR Checks Summary\n\n`;
              content += `ðŸ”„ **Last updated**: ${new Date().toISOString()}\n\n`;

              if (allPassed) {
                content += `âœ… **All checks have passed!** This PR is ready for review and merge.\n\n`;
                content += `ðŸŽ¯ **Auto-assigned to @${context.payload.repository.owner.login}** for review and merge approval.\n\n`;
              } else {
                content += `âŒ **Some checks have failed.** Please review the details below and address any issues.\n\n`;
                content += `ðŸŽ¯ **Auto-assigned to PR author** to address the failed checks.\n\n`;
              }

              // Helper function to get status icon and details for a check result
              function getCheckStatus(result, successDetails, failureDetails, warningDetails = null) {
                const statusMap = new Map([
                  ['success', { statusIcon: 'âœ…', details: successDetails }],
                  ['failure', { statusIcon: 'âŒ', details: failureDetails }],
                  ['default', { statusIcon: 'âš ï¸', details: warningDetails || 'Check did not complete' }]
                ]);
                
                return statusMap.get(result) || statusMap.get('default');
              }

              // Add detailed status table
              content += `### ðŸ“Š Check Results\n\n`;
              content += `| Check | Status | Details |\n`;
              content += `|-------|--------|----------|\n`;

              // Author check results
              if (jobResults.initialAuthorCheckPr !== 'skipped') {
                const authorType = isPrBot ? 'Bot' : 'User';
                const { statusIcon } = getCheckStatus(jobResults.initialAuthorCheckPr, '', '');
                content += `| ðŸ” Author Detection (PR) | ${statusIcon} ${capitalizeStatus(jobResults.initialAuthorCheckPr)} | Detected ${authorType} PR |\n`;
              }

              if (jobResults.initialAuthorCheckManual !== 'skipped') {
                const authorType = isManualBot ? 'Bot' : 'User';
                const { statusIcon } = getCheckStatus(jobResults.initialAuthorCheckManual, '', '');
                content += `| ðŸ” Author Detection (Manual) | ${statusIcon} ${capitalizeStatus(jobResults.initialAuthorCheckManual)} | Detected ${authorType} PR |\n`;
              }

              // Code quality checks
              if (isBot && jobResults.qualityLintFormatBot !== 'skipped') {
                const { statusIcon, details } = getCheckStatus(
                  jobResults.qualityLintFormatBot,
                  'Code quality checks passed',
                  'Linting or formatting issues found'
                );
                content += `| ðŸ§¹ Code Quality (Bot) | ${statusIcon} ${capitalizeStatus(jobResults.qualityLintFormatBot)} | ${details} |\n`;
              }

              if (!isBot && jobResults.qualityLintFormatUser !== 'skipped') {
                const { statusIcon, details } = getCheckStatus(
                  jobResults.qualityLintFormatUser,
                  'Code quality checks passed',
                  'Linting or formatting issues found'
                );
                content += `| ðŸ§¹ Code Quality (User) | ${statusIcon} ${capitalizeStatus(jobResults.qualityLintFormatUser)} | ${details} |\n`;
              }

              // Changelog checks
              if (isBot && jobResults.changelogUpdateDependabot !== 'skipped') {
                const { statusIcon, details } = getCheckStatus(
                  jobResults.changelogUpdateDependabot,
                  changelogUpdated ? 'Changelog automatically updated' : 'Not applicable',
                  'Changelog update failed or not applicable'
                );
                content += `| ðŸ“ Changelog Update (Bot) | ${statusIcon} ${capitalizeStatus(jobResults.changelogUpdateDependabot)} | ${details} |\n`;
              }

              if (!isBot) {
                if (jobResults.changelogCheckUser !== 'skipped') {
                  const { statusIcon, details } = getCheckStatus(
                    jobResults.changelogCheckUser,
                    changelogHasChanges ? 'Changelog changes detected' : 'No changelog changes found',
                    'Changelog check failed'
                  );
                  content += `| ðŸ“‹ Changelog Check (User) | ${statusIcon} ${capitalizeStatus(jobResults.changelogCheckUser)} | ${details} |\n`;
                }
                
                if (jobResults.changelogEnforceUser !== 'skipped') {
                  const { statusIcon, details } = getCheckStatus(
                    jobResults.changelogEnforceUser,
                    'Changelog requirement satisfied',
                    'Changelog update required - please update CHANGELOG.md',
                    'Changelog enforcement check did not complete'
                  );
                  content += `| âœ… Changelog Enforcement | ${statusIcon} ${capitalizeStatus(jobResults.changelogEnforceUser)} | ${details} |\n`;
                }
              }

              // Milestone check
              if (jobResults.metadataMilestoneCheck !== 'skipped') {
                const { statusIcon, details } = getCheckStatus(
                  jobResults.metadataMilestoneCheck,
                  'Milestone added or verified',
                  'Failed to add milestone'
                );
                content += `| ðŸ·ï¸ Milestone Check | ${statusIcon} ${capitalizeStatus(jobResults.metadataMilestoneCheck)} | ${details} |\n`;
              }

              // Add failure details if any
              if (!allPassed) {
                content += `\n### â— Issues to Address\n\n`;
                
                const failures = [];
                const skippedRequired = [];

                // Check for actual failures
                Object.entries(jobResults).forEach(([job, result]) => {
                  if (result === 'failure') {
                    switch (job) {
                      case 'qualityLintFormatUser':
                      case 'qualityLintFormatBot':
                        failures.push('**Code Quality Issues**: Please fix linting or formatting errors. Run the lint and format commands locally to see specific issues.');
                        break;
                      case 'changelogEnforceUser':
                        failures.push('**Changelog Required**: Please update the `public/CHANGELOG.md` file with details about your changes.');
                        break;
                      case 'metadataMilestoneCheck':
                        failures.push('**Milestone Assignment**: Failed to automatically assign a milestone to this PR.');
                        break;
                      case 'changelogUpdateDependabot':
                        failures.push('**Changelog Update Failed**: Automatic changelog update for dependency changes failed.');
                        break;
                      case 'initialAuthorCheckPr':
                      case 'initialAuthorCheckManual':
                        failures.push('**Author Detection Failed**: Unable to determine if this is a bot or user PR.');
                        break;
                      default:
                        failures.push(`**${job}**: Check failed - please review the workflow logs for details.`);
                    }
                  } else if (result === 'skipped') {
                    // Only report skipped jobs that should have run
                    const isRequiredSkipped = (
                      (job === 'qualityLintFormatUser' && !isBot) ||
                      (job === 'qualityLintFormatBot' && isBot) ||
                      (job === 'metadataMilestoneCheck')
                    );
                    
                    if (isRequiredSkipped) {
                      skippedRequired.push(job);
                    }
                  }
                });

                // Add failure descriptions
                failures.forEach((failure, index) => {
                  content += `${index + 1}. ${failure}\n`;
                });

                // Add skipped required job warnings
                if (skippedRequired.length > 0) {
                  content += `\nâš ï¸ **Required checks were skipped**: Some necessary checks did not run, which may indicate a workflow configuration issue.\n`;
                }

                content += `\nðŸ’¡ **Next Steps**: Please address the issues above and push new commits to re-trigger the checks.\n`;
              } else {
                content += `\nðŸŽ‰ **Great job!** All automated checks have passed. Your PR is ready for human review.\n`;
              }

              // Add footer
              content += `\n---\n*This comment was automatically generated by the PR checks workflow.*`;
              
              return content;
            }

            try {
              // Search for existing bot comment with our marker (with pagination to handle PRs with many comments)
              console.log('Searching for existing PR checks comment...');
              
              let botComment = null;
              let page = 1;
              let hasMorePages = true;
              
              // Search through all comment pages to find our bot comment
              while (hasMorePages && !botComment) {
                console.log(`Fetching comments page ${page}...`);
                const commentsResponse = await github.rest.issues.listComments({
                  owner,
                  repo,
                  issue_number: prNumber,
                  per_page: 100, // Maximum allowed per page
                  page: page
                });

                // Look for our comment by the hidden marker AND verify it's from a bot
                botComment = commentsResponse.data.find(comment => {
                  if (!comment.body || !comment.body.includes('<!-- PR_CHECKS_BOT_COMMENT -->')) {
                    return false;
                  }
                  
                  // Define known bot accounts that can create/update PR check comments
                  const allowedBotAccounts = [
                    'github-actions[bot]',
                    'github-actions',
                    'githubactions',  // Alternative naming
                  ];
                  
                  // Verify the comment is from an allowed bot account to prevent overwriting user comments
                  const isAllowedBot = allowedBotAccounts.includes(comment.user.login.toLowerCase()) ||
                                       comment.user.login.endsWith('[bot]') && 
                                       (comment.user.login.includes('github-actions') || comment.user.login.includes('githubactions'));
                  
                  if (!isAllowedBot) {
                    console.log(`Found comment with marker but from non-allowed user: ${comment.user.login} (ID: ${comment.id}). Skipping update to prevent overwriting user content.`);
                    return false;
                  }
                  
                  return true;
                });

                // Check if there are more pages
                hasMorePages = commentsResponse.data.length === 100;
                page++;
                
                // Safety limit to prevent infinite loops (GitHub has a practical limit anyway)
                if (page > 50) {
                  console.log('Reached maximum page search limit (50 pages = ~5000 comments)');
                  break;
                }
              }

              console.log(botComment ? 
                `Found existing bot comment (ID: ${botComment.id}) from user: ${botComment.user.login}` : 
                'No existing bot comment found'
              );

              const commentBody = buildCommentContent();

              if (botComment) {
                // Update existing comment (verified to be from bot)
                console.log(`Updating existing bot comment (ID: ${botComment.id}) from user: ${botComment.user.login}`);
                await github.rest.issues.updateComment({
                  owner,
                  repo,
                  comment_id: botComment.id,
                  body: commentBody
                });
                console.log('Existing PR comment updated successfully');
              } else {
                // Create new comment
                console.log('No existing comment found, creating new one');
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: prNumber,
                  body: commentBody
                });
                console.log('New PR comment created successfully');
              }
            } catch (commentError) {
              console.error(`Error managing PR comment: ${commentError.message}`);
              // Don't fail the workflow if commenting fails
            }
