name: Pull Request Checks

on:
  pull_request:
    types: [opened, reopened, synchronize, edited, ready_for_review, demilestoned]
  issue_comment:
    types: [created]

# Add concurrency to cancel in-progress runs on new commits
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  statuses: write

jobs:
  #################################################
  # COMMENT CHECK - For manual trigger via !check
  #################################################
  check-manual-trigger:
    if: ${{ github.event_name == 'issue_comment' && github.event.issue.pull_request }}
    name: ðŸ” Check Manual Trigger
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check-command.outputs.should_run }}
      pr_number: ${{ steps.get-pr.outputs.pr_number }}
    steps:
      - name: Check for command and owner
        id: check-command
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const comment = context.payload.comment.body;
            const commenter = context.payload.comment.user.login;

            // Check if the comment contains the command and is from repo owner
            // More strict matching: must be at beginning of line and a standalone word
            const isCommand = /^!check\b/.test(comment.trim());
            const isRepoOwner = context.payload.repository.owner.login === commenter;

            const shouldRun = isCommand && isRepoOwner;

            console.log(`Comment: "${comment}"`);
            console.log(`Commenter: ${commenter}`);
            console.log(`Is Owner: ${isRepoOwner}`);
            console.log(`Is Command: ${isCommand}`);
            console.log(`Should Run: ${shouldRun}`);

            core.setOutput('should_run', shouldRun.toString());

            // Comment with acknowledgment if it's the command
            if (isCommand) {
              if (isRepoOwner) {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: 'âœ… PR check workflow manually triggered by repository owner.'
                });
              } else {
                await github.rest.issues.createComment({
                  issue_number: context.issue.number,
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  body: 'âš ï¸ Only repository owners can trigger the PR check workflow manually.'
                });
              }
            }

      - name: Get PR number
        id: get-pr
        if: ${{ steps.check-command.outputs.should_run == 'true' }}
        uses: actions/github-script@v7.0.1
        with:
          script: |
            // Comment is on a PR issue
            const prNumber = context.issue.number;
            console.log(`PR Number: ${prNumber}`);
            core.setOutput('pr_number', prNumber);

  #################################################
  # INITIAL CHECK - Author detection for PR events
  #################################################
  initial-author-check-pr:
    if: ${{ github.event_name == 'pull_request' }}
    name: ðŸ” Initial PR Author Check
    uses: ./.github/workflows/check_bot_author.yml
    with:
      pr_number: ${{ github.event.pull_request.number }}
      event_type: 'pull_request'

  #################################################
  # INITIAL CHECK - Author detection for manual triggers
  #################################################
  initial-author-check-manual:
    needs: [check-manual-trigger]
    if: ${{ github.event_name == 'issue_comment' && needs.check-manual-trigger.outputs.should_run == 'true' }}
    name: ðŸ” Initial PR Author Check (Manual)
    uses: ./.github/workflows/check_bot_author.yml
    with:
      pr_number: ${{ needs.check-manual-trigger.outputs.pr_number }}
      event_type: 'issue_comment'

  #################################################
  # CHANGELOG CHECKS
  #################################################
  changelog-update-dependabot:
    name: ðŸ“ Update Changelog (Dependabot)
    needs: [initial-author-check-pr, initial-author-check-manual]
    if: |
      always() &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_dependabot == 'true') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_dependabot == 'true')
      )
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    outputs:
      changelog_updated: ${{ steps.extract-info.outputs.has_match }}
      package_name: ${{ steps.extract-info.outputs.package }}
      from_version: ${{ steps.extract-info.outputs.from_version }}
      to_version: ${{ steps.extract-info.outputs.to_version }}
      dep_type: ${{ steps.update-changelog.outputs.dep_type }}
      commit_sha: ${{ steps.update-changelog.outputs.commit_sha }}
    steps:
      - uses: actions/checkout@v4.2.2
        with:
          ref: ${{ github.head_ref }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Extract dependency information
        id: extract-info
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          # Pattern for conventional commit format: build(deps): bump package from version to version
          if [[ "$PR_TITLE" =~ build\(deps.*\):\ bump\ ([^\ ]+)\ from\ ([0-9]+[\.0-9]*)\ to\ ([0-9]+[\.0-9]*) ]]; then
            PACKAGE="${BASH_REMATCH[1]}"
            FROM_VERSION="${BASH_REMATCH[2]}"
            TO_VERSION="${BASH_REMATCH[3]}"
            echo "package=$PACKAGE" >> $GITHUB_OUTPUT
            echo "from_version=$FROM_VERSION" >> $GITHUB_OUTPUT
            echo "to_version=$TO_VERSION" >> $GITHUB_OUTPUT
            echo "has_match=true" >> $GITHUB_OUTPUT
          else
            echo "has_match=false" >> $GITHUB_OUTPUT
          fi

      - name: Update CHANGELOG.md
        id: update-changelog
        if: steps.extract-info.outputs.has_match == 'true'
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          CHANGELOG_FILE="public/CHANGELOG.md"
          PACKAGE="${{ steps.extract-info.outputs.package }}"
          FROM_VERSION="${{ steps.extract-info.outputs.from_version }}"
          TO_VERSION="${{ steps.extract-info.outputs.to_version }}"

          if [ ! -f "$CHANGELOG_FILE" ]; then
            echo "Error: CHANGELOG.md not found at $CHANGELOG_FILE"
            exit 1
          fi

          # Determine the type of dependency
          DEP_TYPE="dependency"
          if [[ "$PR_TITLE" == *"deps-dev"* ]]; then
            DEP_TYPE="dev dependency"
          fi
          echo "dep_type=$DEP_TYPE" >> $GITHUB_OUTPUT

          # Find the first version section line and the next section (if any)
          FIRST_VERSION_LINE=$(grep -n "^## " "$CHANGELOG_FILE" | head -1 | cut -d: -f1)
          NEXT_VERSION_LINE=$(grep -n "^---" "$CHANGELOG_FILE" | head -1 | cut -d: -f1)

          # If there's no next section (no "---" line found), insert before the end of the file
          if [ -z "$NEXT_VERSION_LINE" ]; then
            INSERT_LINE="$(($(wc -l < "$CHANGELOG_FILE")+1))"
          else
            # Insert right before the "---" separator
            INSERT_LINE="$((NEXT_VERSION_LINE-1))"
          fi

          # Format the changelog entry
          ENTRY="- Bump $DEP_TYPE \`$PACKAGE\` from $FROM_VERSION to $TO_VERSION"

          # Insert the entry before the separator line or at the end of file
          sed -i "${INSERT_LINE}i $ENTRY" "$CHANGELOG_FILE"

          # Commit and push the changes
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          git add "$CHANGELOG_FILE"
          git commit -m "docs: update changelog with $PACKAGE dependency bump"
          git push

          # Get the commit SHA of the new commit we just pushed
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "Updated changelog with commit: $COMMIT_SHA"

      - name: Comment on PR about changelog update
        if: steps.extract-info.outputs.has_match == 'true'
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const packageName = '${{ steps.extract-info.outputs.package }}';
            const fromVersion = '${{ steps.extract-info.outputs.from_version }}';
            const toVersion = '${{ steps.extract-info.outputs.to_version }}';
            const depType = '${{ steps.update-changelog.outputs.dep_type }}';

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `ðŸ“ **Changelog Automatically Updated**\n\nA changelog entry has been automatically added for this Dependabot PR:\n\n- Bump ${depType} ${packageName} from ${fromVersion} to ${toVersion}`
            });

  changelog-check-user:
    name: ðŸ“‹ Check Changelog (User PR)
    needs: [initial-author-check-pr, initial-author-check-manual]
    if: |
      always() &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'false') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'false')
      )
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.changelog-check.outputs.changed }}
    steps:
      - uses: actions/checkout@v4.2.2
      - name: Check for changelog changes
        id: changelog-check
        run: |
          git fetch origin ${{ github.base_ref }} --depth=1
          CHANGELOG_CHANGED=$(git diff --name-only origin/${{ github.base_ref }} | grep -c "public/CHANGELOG.md" || true)
          echo "changed=$CHANGELOG_CHANGED" >> $GITHUB_OUTPUT

  changelog-enforce-user:
    name: âœ… Enforce Changelog (User PR)
    needs: [initial-author-check-pr, initial-author-check-manual, changelog-check-user]
    if: |
      always() &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'false') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'false')
      )
    runs-on: ubuntu-latest
    outputs:
      should_block: ${{ steps.check-status.outputs.should_block }}
    steps:
      - uses: actions/checkout@v4.2.2

      - name: Handle changelog enforcement
        id: check-status
        run: |
          HAS_CHANGES="${{ needs.changelog-check-user.outputs.has_changes }}"

          # Always try to remove the label first if changes exist
          if [[ "$HAS_CHANGES" != "0" ]]; then
            echo "Changelog changes detected - removing label if it exists"
            gh pr edit ${{ github.event.pull_request.number }} --remove-label "Changelog needed" 2>/dev/null || true
          fi

          # For non-bot PRs, check if changelog was updated
          if [[ "$HAS_CHANGES" == "0" ]]; then
            echo "User PR detected without changelog changes - blocking"
            gh label create "Changelog needed" --color FF0000 --description "Changelog update required" 2>/dev/null || true
            gh pr edit ${{ github.event.pull_request.number }} --add-label "Changelog needed"
            echo "should_block=true" >> $GITHUB_OUTPUT
          else
            echo "User PR detected with changelog changes - allowing"
            echo "should_block=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  #################################################
  # CODE QUALITY CHECKS
  #################################################
  # For non-bot PRs - runs immediately
  quality-lint-format-user:
    needs: [initial-author-check-pr, initial-author-check-manual]
    if: |
      always() &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'false') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'false')
      )
    uses: ./.github/workflows/lint_format.yml
    with:
      job-name: 'ðŸ§¹ Code Quality Checks'

  # For bot PRs - waits for changelog update to finish
  quality-lint-format-bot:
    # Wait for changelog update to complete for bot PRs
    needs: [initial-author-check-pr, initial-author-check-manual, changelog-update-dependabot]
    if: |
      always() &&
      (
        (needs.initial-author-check-pr.result == 'success' && needs.initial-author-check-pr.outputs.is_bot == 'true') || 
        (needs.initial-author-check-manual.result == 'success' && needs.initial-author-check-manual.outputs.is_bot == 'true')
      )
    uses: ./.github/workflows/lint_format.yml
    with:
      job-name: 'ðŸ§¹ Code Quality Checks (Bot PR)'

  #################################################
  # PR METADATA CHECKS
  #################################################
  metadata-milestone-check:
    name: ðŸ·ï¸ PR Milestone Check
    needs:
      - initial-author-check-pr
      - initial-author-check-manual
      - quality-lint-format-user
      - quality-lint-format-bot
    # This ensures it only needs one of the two lint jobs to complete based on PR author type
    if: ${{ always() && !contains(needs.*.result, 'cancelled') }}
    runs-on: ubuntu-latest
    steps:
      - name: Check if PR has milestone
        id: check-milestone
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = context.payload.pull_request.number;

            // Check if PR has a milestone
            const pr = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber
            });

            if (pr.data.milestone) {
              console.log(`PR #${prNumber} already has milestone: ${pr.data.milestone.title}`);
              return true;
            }

            // Get latest milestone
            const milestones = await github.rest.issues.listMilestones({
              owner,
              repo,
              state: 'open',
              sort: 'due_on',
              direction: 'desc'
            });

            if (milestones.data.length === 0) {
              console.log('No milestones found!');
              core.setFailed('No milestones available to add to PR');
              return false;
            }

            // Sort by creation date (newest first)
            const sortedMilestones = milestones.data.sort((a, b) => 
              new Date(b.created_at) - new Date(a.created_at)
            );

            const latestMilestone = sortedMilestones[0];
            console.log(`Latest milestone: ${latestMilestone.title}`);

            // Update the PR with the latest milestone
            await github.rest.issues.update({
              owner,
              repo,
              issue_number: prNumber,
              milestone: latestMilestone.number
            });

            // Add comment to PR
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: `âœ… Automatically added milestone ${latestMilestone.title} to this pull request.`
            });

            console.log(`Added milestone ${latestMilestone.title} to PR #${prNumber}`);
            return true;

  #################################################
  # FINAL STATUS CHECK
  #################################################
  final-status:
    name: ðŸš¦ Final Status Check
    needs:
      - initial-author-check-pr
      - initial-author-check-manual
      - quality-lint-format-user
      - quality-lint-format-bot
      - metadata-milestone-check
      - changelog-update-dependabot
      - changelog-check-user
      - changelog-enforce-user
    if: ${{ always() }}
    runs-on: ubuntu-latest
    steps:
      - name: Set job status variables
        id: set-status
        run: |
          # Determine if this is a bot PR regardless of trigger type
          IS_BOT_PR="false"
          IS_BOT_MANUAL="false"

          if [[ "${{ needs.initial-author-check-pr.result }}" == "success" ]]; then
            IS_BOT_PR="${{ needs.initial-author-check-pr.outputs.is_bot }}"
          fi

          if [[ "${{ needs.initial-author-check-manual.result }}" == "success" ]]; then
            IS_BOT_MANUAL="${{ needs.initial-author-check-manual.outputs.is_bot }}"
          fi

          # If either path determined it's a bot, set is_bot=true
          if [[ "$IS_BOT_PR" == "true" || "$IS_BOT_MANUAL" == "true" ]]; then
            echo "is_bot=true" >> $GITHUB_OUTPUT
          else
            echo "is_bot=false" >> $GITHUB_OUTPUT
          fi

      - name: Generate status report
        run: |
          echo "## ðŸ“Š PR Checks Status Report"
          echo ""
          echo "| Check | Status | Result |"
          echo "|-------|--------|--------|"

          # Check which trigger path was used
          if [[ "${{ needs.initial-author-check-pr.result }}" == "success" ]]; then
            echo "| ðŸ” Initial Author Check (PR) | ${{ needs.initial-author-check-pr.result }} | PR is by ${{ needs.initial-author-check-pr.outputs.is_bot == 'true' && 'bot' || 'user' }} |"
          fi

          if [[ "${{ needs.initial-author-check-manual.result }}" == "success" ]]; then
            echo "| ðŸ” Initial Author Check (Manual) | ${{ needs.initial-author-check-manual.result }} | PR is by ${{ needs.initial-author-check-manual.outputs.is_bot == 'true' && 'bot' || 'user' }} |"
          fi

          # Rest remains the same
          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            echo "| ðŸ“ Update Changelog (Bot) | ${{ needs.changelog-update-dependabot.result }} | ${{ needs.changelog-update-dependabot.outputs.changelog_updated == 'true' && 'Updated' || 'Not applicable' }} |"
            echo "| ðŸ§¹ Code Quality (Bot) | ${{ needs.quality-lint-format-bot.result }} | - |"
          else
            echo "| ðŸ“‹ Check Changelog (User) | ${{ needs.changelog-check-user.result }} | Changes: ${{ needs.changelog-check-user.outputs.has_changes != '0' && 'Yes' || 'No' }} |"
            echo "| âœ… Enforce Changelog | ${{ needs.changelog-enforce-user.result }} | Should block: ${{ needs.changelog-enforce-user.outputs.should_block }} |"
            echo "| ðŸ§¹ Code Quality (User) | ${{ needs.quality-lint-format-user.result }} | - |"
          fi

          echo "| ðŸ·ï¸ PR Milestone Check | ${{ needs.metadata-milestone-check.result }} | - |"

      # Split failure check to its own step with if condition
      - name: Check for job failures
        if: ${{ contains(needs.*.result, 'failure') }}
        run: |
          echo "â›” One or more checks failed - blocking merge"

          # List which checks failed
          if [[ "${{ needs.initial-author-check-pr.result }}" == "failure" ]]; then
            echo "- âŒ Initial author check (PR) failed"
          fi

          if [[ "${{ needs.initial-author-check-manual.result }}" == "failure" ]]; then
            echo "- âŒ Initial author check (Manual) failed"
          fi

          if [[ "${{ needs.metadata-milestone-check.result }}" == "failure" ]]; then
            echo "- âŒ Milestone check failed"
          fi

          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            if [[ "${{ needs.quality-lint-format-bot.result }}" == "failure" ]]; then
              echo "- âŒ Code quality checks (bot) failed"
            fi
            if [[ "${{ needs.changelog-update-dependabot.result }}" == "failure" ]]; then
              echo "- âŒ Changelog update for bot failed"
            fi
          else
            if [[ "${{ needs.quality-lint-format-user.result }}" == "failure" ]]; then
              echo "- âŒ Code quality checks (user) failed"
            fi
            if [[ "${{ needs.changelog-check-user.result }}" == "failure" ]]; then
              echo "- âŒ Changelog check failed"
            fi
            if [[ "${{ needs.changelog-enforce-user.result }}" == "failure" ]]; then
              echo "- âŒ Changelog enforcement failed"
            fi
          fi

          exit 1

      - name: Check for skipped jobs (non-bot PR)
        if: ${{ steps.set-status.outputs.is_bot == 'false' }}
        env:
          QUALITY_STATUS: ${{ needs.quality-lint-format-user.result }}
          MILESTONE_STATUS: ${{ needs.metadata-milestone-check.result }}
        run: |
          if [[ "$QUALITY_STATUS" == "skipped" || "$MILESTONE_STATUS" == "skipped" ]]; then
            echo "âš ï¸ Required checks were skipped - blocking merge"
            
            if [[ "$QUALITY_STATUS" == "skipped" ]]; then
              echo "- âš ï¸ Code quality checks were skipped"
            fi
            
            if [[ "$MILESTONE_STATUS" == "skipped" ]]; then
              echo "- âš ï¸ Milestone checks were skipped"
            fi
            
            exit 1
          fi

      - name: Check for skipped jobs (bot PR)
        if: ${{ steps.set-status.outputs.is_bot == 'true' }}
        env:
          BOT_QUALITY_STATUS: ${{ needs.quality-lint-format-bot.result }}
          MILESTONE_STATUS: ${{ needs.metadata-milestone-check.result }}
        run: |
          if [[ "$BOT_QUALITY_STATUS" == "skipped" || "$MILESTONE_STATUS" == "skipped" ]]; then
            echo "âš ï¸ Required checks were skipped - blocking merge"
            
            if [[ "$BOT_QUALITY_STATUS" == "skipped" ]]; then
              echo "- âš ï¸ Bot code quality checks were skipped"
            fi
            
            if [[ "$MILESTONE_STATUS" == "skipped" ]]; then
              echo "- âš ï¸ Milestone checks were skipped"
            fi
            
            exit 1
          fi

      - name: Success message
        run: |
          echo "âœ… All PR checks completed successfully"

          # Provide a summary of what was run
          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            echo "Bot PR detected - ran bot-specific workflows"
            echo "- âœ“ Initial author check (completed)"
            echo "- âœ“ Bot code quality check (completed)"
            echo "- âœ“ Milestone check (completed)"
            if [[ "${{ needs.changelog-update-dependabot.result }}" != 'skipped' ]]; then
              echo "- âœ“ Changelog auto-update (completed)"
            fi
          else
            echo "User PR detected - ran user-specific workflows"
            echo "- âœ“ Initial author check (completed)"
            echo "- âœ“ User code quality check (completed)"
            echo "- âœ“ Milestone check (completed)"
            if [[ "${{ needs.changelog-check-user.result }}" != 'skipped' ]]; then
              echo "- âœ“ Changelog check (completed)"
            fi
          fi

      # Use GitHub API to explicitly report status (works better for Dependabot PRs)
      - name: Explicitly report final status
        if: ${{ always() }}
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const prRef = context.payload.pull_request;
            let sha = prRef?.head?.sha;

            if (!sha) {
              console.log('No SHA found in PR head, falling back to event SHA');
              sha = context.sha;
            }

            const jobStatus = '${{ job.status }}';
            const isBot = '${{ steps.set-status.outputs.is_bot }}' === 'true';
            const changelogUpdateOutput = '${{ needs.changelog-update-dependabot.outputs.commit_sha }}';

            // For Dependabot PRs with changelog updates, get the latest commit from the branch
            if (isBot) {
              try {
                // Fetch the latest commit from the PR branch regardless of what we have in event payload
                // This ensures we always use the most up-to-date SHA after any workflow modifications
                const { data: prData } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: context.payload.pull_request.number
                });
                
                if (prData && prData.head && prData.head.sha) {
                  console.log(`Using latest SHA from PR API: ${prData.head.sha}`);
                  console.log(`Previous SHA from event: ${sha}`);
                  sha = prData.head.sha;
                }
                
                // Additional fallback - if we have a specific commit SHA from changelog update, use it
                if (changelogUpdateOutput && changelogUpdateOutput.length > 0) {
                  console.log(`Changelog update produced commit: ${changelogUpdateOutput}`);
                  console.log(`Comparing to latest PR SHA: ${sha}`);
                  
                  // Only use the changelog commit if it's different from what we already have
                  if (changelogUpdateOutput !== sha) {
                    console.log(`Using changelog update commit SHA: ${changelogUpdateOutput}`);
                    sha = changelogUpdateOutput;
                  }
                }
              } catch (apiError) {
                console.error(`Error fetching latest PR data: ${apiError.message}`);
                console.log(`Falling back to original SHA: ${sha}`);
                // Continue with the original SHA
              }
            } else {
              console.log(`Using original PR head SHA for user PR: ${sha}`);
            }

            console.log(`Reporting final status for ${owner}/${repo}@${sha}: ${jobStatus}`);

            // Set state based on job status
            let state = 'success';
            let description = 'All PR checks completed successfully';

            if (jobStatus !== 'success') {
              state = 'failure';
              description = 'One or more PR checks failed';
            }

            try {
              // Explicitly create a status check for the Final Status Check
              // Note: Removed emoji from context to avoid 4-byte Unicode validation errors
              const statusResponse = await github.rest.repos.createCommitStatus({
                owner,
                repo,
                sha,
                state,
                description,
                context: 'Final Status Check'
              });
              
              console.log(`Status check created with state: ${state}, response status: ${statusResponse.status}`);
            } catch (error) {
              console.error(`Error creating status check: ${error.message}`);
              console.error(`Error details: ${JSON.stringify(error)}`);
              
              // Add a brief backoff before retry to reduce transient API race conditions
              console.log('Adding brief backoff (1 second) before retry...');
              await new Promise(resolve => setTimeout(resolve, 1000));
              
              // Try again with the current context SHA as fallback
              console.log(`Retrying with context SHA: ${context.sha}`);
              try {
                const fallbackResponse = await github.rest.repos.createCommitStatus({
                  owner,
                  repo,
                  sha: context.sha,
                  state,
                  description: description + " (fallback)",
                  context: 'Final Status Check'
                });
                console.log(`Fallback status check created with state: ${state}, response status: ${fallbackResponse.status}`);
              } catch (fallbackError) {
                console.error(`Error creating fallback status check: ${fallbackError.message}`);
                console.error(`Fallback error details: ${JSON.stringify(fallbackError)}`);
                
                // If both attempts fail, add additional logging for troubleshooting
                console.log('Both status creation attempts failed - this may require manual verification');
              }
            }

            // Exit with appropriate code using core.setFailed() for better consistency with GitHub Actions
            if (jobStatus !== 'success') {
              core.setFailed(`One or more PR checks failed with status: ${jobStatus}`);
            }
