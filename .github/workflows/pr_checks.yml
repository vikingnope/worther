name: Pull Request Checks

on:
  pull_request:
    types: [opened, reopened, synchronize, edited, ready_for_review, demilestoned]
  issue_comment:
    types: [created]

# Add concurrency to cancel in-progress runs on new commits
concurrency:
  group: ${{ github.workflow }}-${{ github.event.pull_request.number || github.ref }}
  cancel-in-progress: true

permissions:
  contents: write
  pull-requests: write
  issues: write
  statuses: write

jobs:
  #################################################
  # COMMENT COMMAND CHECK
  #################################################
  check-comment:
    name: 🔎 Check Comment Command
    if: ${{ github.event_name == 'issue_comment' }}
    runs-on: ubuntu-latest
    outputs:
      should_run: ${{ steps.check-command.outputs.should_run }}
      pr_number: ${{ steps.get-pr-number.outputs.pr_number }}
    steps:
      - name: Check if comment is !check and from repo owner
        id: check-command
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const { owner, repo } = context.repo;
            const comment = context.payload.comment;
            const commentBody = comment.body.trim();
            const commentUser = comment.user.login;

            // Check if the comment is exactly "!check"
            if (commentBody !== '!check') {
              console.log(`Comment "${commentBody}" is not a recognized command`);
              return core.setOutput('should_run', 'false');
            }

            // Check if this is a PR comment
            if (!context.payload.issue.pull_request) {
              console.log('Comment is not on a pull request');
              return core.setOutput('should_run', 'false');
            }

            // Determine if the commenter is the repo owner
            try {
              const repoData = await github.rest.repos.get({
                owner,
                repo
              });
              
              const repoOwner = repoData.data.owner.login;
              
              if (commentUser === repoOwner) {
                console.log(`Comment is from repository owner ${repoOwner} - running checks`);
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: context.payload.issue.number,
                  body: '🔄 Running PR checks as requested by repository owner...'
                });
                return core.setOutput('should_run', 'true');
              } else {
                console.log(`Comment is from ${commentUser}, not the repo owner ${repoOwner}`);
                await github.rest.issues.createComment({
                  owner,
                  repo,
                  issue_number: context.payload.issue.number,
                  body: '❌ Only the repository owner can run checks with the `!check` command.'
                });
                return core.setOutput('should_run', 'false');
              }
            } catch (error) {
              console.error(`Error checking repository owner: ${error}`);
              return core.setOutput('should_run', 'false');
            }

      - name: Get PR number
        id: get-pr-number
        if: steps.check-command.outputs.should_run == 'true'
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const prNumber = context.payload.issue.number;
            console.log(`Getting PR data for #${prNumber}`);
            core.setOutput('pr_number', prNumber);

  #################################################
  # INITIAL CHECK - Author detection
  #################################################
  initial-author-check:
    name: 🔍 Initial PR Author Check
    needs: [check-comment]
    if: |
      (github.event_name == 'pull_request') || 
      (github.event_name == 'issue_comment' && needs.check-comment.outputs.should_run == 'true')
    runs-on: ubuntu-latest
    outputs:
      is_bot: ${{ steps.check-bot.outputs.is_bot }}
      is_dependabot: ${{ steps.check-bot.outputs.is_dependabot }}
    steps:
      - name: Get PR data for issue comment
        id: get-pr-data
        if: ${{ github.event_name == 'issue_comment' }}
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const { owner, repo } = context.repo;
            const prNumber = ${{ needs.check-comment.outputs.pr_number }};

            try {
              console.log(`Fetching PR #${prNumber} data`);
              const { data: pr } = await github.rest.pulls.get({
                owner,
                repo,
                pull_number: prNumber
              });
              
              // Store PR data as outputs
              core.setOutput('pr_author', pr.user.login);
              console.log(`PR Author: ${pr.user.login}`);
            } catch (error) {
              console.error(`Error fetching PR data: ${error.message}`);
              core.setFailed(`Failed to get PR data: ${error.message}`);
            }

      - name: Check if PR author is a bot
        id: check-bot
        uses: actions/github-script@v7.0.1
        with:
          script: |
            let prAuthor;

            if ('${{ github.event_name }}' === 'pull_request') {
              prAuthor = context.payload.pull_request.user.login;
            } else {
              // For issue_comment events, use the author we got from the previous step
              prAuthor = '${{ steps.get-pr-data.outputs.pr_author }}';
            }

            // Check if the author is a bot (ends with [bot] or is dependabot)
            const isBot = prAuthor.endsWith('[bot]') || prAuthor.startsWith('dependabot');

            // Check specifically for Dependabot
            const isDependabot = prAuthor.startsWith('dependabot');

            // Set outputs
            core.setOutput('is_bot', isBot.toString());
            core.setOutput('is_dependabot', isDependabot.toString());

            console.log(`PR Author: ${prAuthor}`);
            console.log(`Is Bot: ${isBot}`);
            console.log(`Is Dependabot: ${isDependabot}`);

  #################################################
  # CHANGELOG CHECKS
  #################################################
  changelog-update-dependabot:
    name: 📝 Update Changelog (Dependabot)
    needs: initial-author-check
    if: ${{ needs.initial-author-check.outputs.is_dependabot == 'true' }}
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
      issues: write
    outputs:
      changelog_updated: ${{ steps.extract-info.outputs.has_match }}
      package_name: ${{ steps.extract-info.outputs.package }}
      from_version: ${{ steps.extract-info.outputs.from_version }}
      to_version: ${{ steps.extract-info.outputs.to_version }}
      dep_type: ${{ steps.update-changelog.outputs.dep_type }}
      commit_sha: ${{ steps.update-changelog.outputs.commit_sha }}
    steps:
      - uses: actions/checkout@v4.2.2
        with:
          ref: ${{ github.event_name == 'pull_request' && github.head_ref || format('refs/pull/{0}/head', needs.check-comment.outputs.pr_number) }}
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: Extract dependency information
        id: extract-info
        run: |
          # Get PR title based on event type
          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            PR_TITLE="${{ github.event.pull_request.title }}"
          else
            # For issue_comment events, fetch PR title using GitHub API
            PR_TITLE=$(gh pr view ${{ needs.check-comment.outputs.pr_number }} --json title -q ".title")
          fi

          echo "PR Title: $PR_TITLE"

          # Pattern for conventional commit format: build(deps): bump package from version to version
          if [[ "$PR_TITLE" =~ build\(deps.*\):\ bump\ ([^\ ]+)\ from\ ([0-9]+[\.0-9]*)\ to\ ([0-9]+[\.0-9]*) ]]; then
            PACKAGE="${BASH_REMATCH[1]}"
            FROM_VERSION="${BASH_REMATCH[2]}"
            TO_VERSION="${BASH_REMATCH[3]}"
            echo "package=$PACKAGE" >> $GITHUB_OUTPUT
            echo "from_version=$FROM_VERSION" >> $GITHUB_OUTPUT
            echo "to_version=$TO_VERSION" >> $GITHUB_OUTPUT
            echo "has_match=true" >> $GITHUB_OUTPUT
          else
            echo "has_match=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Update CHANGELOG.md
        id: update-changelog
        if: steps.extract-info.outputs.has_match == 'true'
        env:
          PR_TITLE: ${{ github.event.pull_request.title }}
        run: |
          CHANGELOG_FILE="public/CHANGELOG.md"
          PACKAGE="${{ steps.extract-info.outputs.package }}"
          FROM_VERSION="${{ steps.extract-info.outputs.from_version }}"
          TO_VERSION="${{ steps.extract-info.outputs.to_version }}"

          if [ ! -f "$CHANGELOG_FILE" ]; then
            echo "Error: CHANGELOG.md not found at $CHANGELOG_FILE"
            exit 1
          fi

          # Determine the type of dependency
          DEP_TYPE="dependency"
          if [[ "$PR_TITLE" == *"deps-dev"* ]]; then
            DEP_TYPE="dev dependency"
          fi
          echo "dep_type=$DEP_TYPE" >> $GITHUB_OUTPUT

          # Find the first version section line and the next section (if any)
          FIRST_VERSION_LINE=$(grep -n "^## " "$CHANGELOG_FILE" | head -1 | cut -d: -f1)
          NEXT_VERSION_LINE=$(grep -n "^---" "$CHANGELOG_FILE" | head -1 | cut -d: -f1)

          # If there's no next section (no "---" line found), insert before the end of the file
          if [ -z "$NEXT_VERSION_LINE" ]; then
            INSERT_LINE="$(($(wc -l < "$CHANGELOG_FILE")+1))"
          else
            # Insert right before the "---" separator
            INSERT_LINE="$((NEXT_VERSION_LINE-1))"
          fi

          # Format the changelog entry
          ENTRY="- Bump $DEP_TYPE \`$PACKAGE\` from $FROM_VERSION to $TO_VERSION"

          # Insert the entry before the separator line or at the end of file
          sed -i "${INSERT_LINE}i $ENTRY" "$CHANGELOG_FILE"

          # Commit and push the changes
          git config --local user.email "github-actions[bot]@users.noreply.github.com"
          git config --local user.name "GitHub Actions"
          git add "$CHANGELOG_FILE"
          git commit -m "docs: update changelog with $PACKAGE dependency bump"
          git push

          # Get the commit SHA of the new commit we just pushed
          COMMIT_SHA=$(git rev-parse HEAD)
          echo "commit_sha=$COMMIT_SHA" >> $GITHUB_OUTPUT
          echo "Updated changelog with commit: $COMMIT_SHA"

      - name: Comment on PR about changelog update
        if: steps.extract-info.outputs.has_match == 'true'
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const packageName = '${{ steps.extract-info.outputs.package }}';
            const fromVersion = '${{ steps.extract-info.outputs.from_version }}';
            const toVersion = '${{ steps.extract-info.outputs.to_version }}';
            const depType = '${{ steps.update-changelog.outputs.dep_type }}';

            await github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: `📝 **Changelog Automatically Updated**\n\nA changelog entry has been automatically added for this Dependabot PR:\n\n- Bump ${depType} ${packageName} from ${fromVersion} to ${toVersion}`
            });

  changelog-check-user:
    name: 📋 Check Changelog (User PR)
    needs: initial-author-check
    # Skip if it's a bot PR
    if: ${{ needs.initial-author-check.outputs.is_bot == 'false' }}
    runs-on: ubuntu-latest
    outputs:
      has_changes: ${{ steps.changelog-check.outputs.changed }}
    steps:
      - uses: actions/checkout@v4.2.2
        with:
          ref: ${{ github.event_name == 'pull_request' && github.event.pull_request.head.sha || format('refs/pull/{0}/head', needs.check-comment.outputs.pr_number) }}

      - name: Check for changelog changes
        id: changelog-check
        run: |
          # Determine PR number based on event type
          PR_NUMBER="${{ github.event_name == 'pull_request' && github.event.pull_request.number || needs.check-comment.outputs.pr_number }}"

          # For issue comment triggers, we need to fetch base branch info from API
          if [[ "${{ github.event_name }}" == "issue_comment" ]]; then
            BASE_REF=$(gh pr view $PR_NUMBER --json baseRefName -q ".baseRefName")
            echo "Base branch: $BASE_REF"
            git fetch origin $BASE_REF --depth=1
            CHANGELOG_CHANGED=$(git diff --name-only origin/$BASE_REF | grep -c "public/CHANGELOG.md" || true)
          else
            # Regular PR event
            git fetch origin ${{ github.base_ref }} --depth=1
            CHANGELOG_CHANGED=$(git diff --name-only origin/${{ github.base_ref }} | grep -c "public/CHANGELOG.md" || true)
          fi

          echo "Changelog changed: $CHANGELOG_CHANGED"
          echo "changed=$CHANGELOG_CHANGED" >> $GITHUB_OUTPUT
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  changelog-enforce-user:
    name: ✅ Enforce Changelog (User PR)
    needs: [initial-author-check, changelog-check-user]
    if: ${{ needs.initial-author-check.outputs.is_bot == 'false' }}
    runs-on: ubuntu-latest
    outputs:
      should_block: ${{ steps.check-status.outputs.should_block }}
    steps:
      - uses: actions/checkout@v4.2.2

      - name: Handle changelog enforcement
        id: check-status
        run: |
          HAS_CHANGES="${{ needs.changelog-check-user.outputs.has_changes }}"

          # Always try to remove the label first if changes exist
          if [[ "$HAS_CHANGES" != "0" ]]; then
            echo "Changelog changes detected - removing label if it exists"
            gh pr edit ${{ github.event.pull_request.number }} --remove-label "Changelog needed" 2>/dev/null || true
          fi

          # For non-bot PRs, check if changelog was updated
          if [[ "$HAS_CHANGES" == "0" ]]; then
            echo "User PR detected without changelog changes - blocking"
            gh label create "Changelog needed" --color FF0000 --description "Changelog update required" 2>/dev/null || true
            gh pr edit ${{ github.event.pull_request.number }} --add-label "Changelog needed"
            echo "should_block=true" >> $GITHUB_OUTPUT
          else
            echo "User PR detected with changelog changes - allowing"
            echo "should_block=false" >> $GITHUB_OUTPUT
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

  #################################################
  # CODE QUALITY CHECKS
  #################################################
  # For non-bot PRs - runs immediately
  quality-lint-format-user:
    needs: [initial-author-check]
    if: ${{ needs.initial-author-check.outputs.is_bot == 'false' }}
    uses: ./.github/workflows/lint_format.yml
    with:
      job-name: '🧹 Code Quality Checks'

  # For bot PRs - waits for changelog update to finish
  quality-lint-format-bot:
    # Wait for changelog update to complete for bot PRs
    needs: [initial-author-check, changelog-update-dependabot]
    if: ${{ needs.initial-author-check.outputs.is_bot == 'true' }}
    uses: ./.github/workflows/lint_format.yml
    with:
      job-name: '🧹 Code Quality Checks (Bot PR)'

  #################################################
  # PR METADATA CHECKS
  #################################################
  metadata-milestone-check:
    name: 🏷️ PR Milestone Check
    needs:
      - initial-author-check
      - quality-lint-format-user
      - quality-lint-format-bot
      - check-comment
    # This ensures it only needs one of the two lint jobs to complete based on PR author type
    if: ${{ always() && !contains(needs.*.result, 'cancelled') }}
    runs-on: ubuntu-latest
    steps:
      - name: Check if PR has milestone
        id: check-milestone
        uses: actions/github-script@v7.0.1
        with:
          script: |
            const { owner, repo } = context.repo;
            let prNumber;

            // Determine PR number based on event type
            if ('${{ github.event_name }}' === 'pull_request') {
              prNumber = context.payload.pull_request.number;
            } else {
              // For issue_comment events
              prNumber = ${{ needs.check-comment.outputs.pr_number }};
            }

            console.log(`Checking milestone for PR #${prNumber}`);

            // Check if PR has a milestone
            const pr = await github.rest.pulls.get({
              owner,
              repo,
              pull_number: prNumber
            });

            if (pr.data.milestone) {
              console.log(`PR #${prNumber} already has milestone: ${pr.data.milestone.title}`);
              return true;
            }

            // Get latest milestone
            const milestones = await github.rest.issues.listMilestones({
              owner,
              repo,
              state: 'open',
              sort: 'due_on',
              direction: 'desc'
            });

            if (milestones.data.length === 0) {
              console.log('No milestones found!');
              core.setFailed('No milestones available to add to PR');
              return false;
            }

            // Sort by creation date (newest first)
            const sortedMilestones = milestones.data.sort((a, b) => 
              new Date(b.created_at) - new Date(a.created_at)
            );

            const latestMilestone = sortedMilestones[0];
            console.log(`Latest milestone: ${latestMilestone.title}`);

            // Update the PR with the latest milestone
            await github.rest.issues.update({
              owner,
              repo,
              issue_number: prNumber,
              milestone: latestMilestone.number
            });

            // Add comment to PR
            await github.rest.issues.createComment({
              owner,
              repo,
              issue_number: prNumber,
              body: `✅ Automatically added milestone ${latestMilestone.title} to this pull request.`
            });

            console.log(`Added milestone ${latestMilestone.title} to PR #${prNumber}`);
            return true;

  #################################################
  # FINAL STATUS CHECK
  #################################################
  final-status:
    name: 🚦 Final Status Check
    needs:
      - initial-author-check
      - quality-lint-format-user
      - quality-lint-format-bot
      - metadata-milestone-check
      - changelog-update-dependabot
      - changelog-check-user
      - changelog-enforce-user
    if: ${{ always() }}
    runs-on: ubuntu-latest
    steps:
      - name: Set job status variables
        id: set-status
        run: |
          IS_BOT="${{ needs.initial-author-check.outputs.is_bot }}"
          echo "is_bot=$IS_BOT" >> $GITHUB_OUTPUT

      - name: Generate status report
        run: |
          echo "## 📊 PR Checks Status Report"
          echo ""
          echo "| Check | Status | Result |"
          echo "|-------|--------|--------|"
          echo "| 🔍 Initial Author Check | ${{ needs.initial-author-check.result }} | PR is by ${{ needs.initial-author-check.outputs.is_bot == 'true' && 'bot' || 'user' }} |"

          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            echo "| 📝 Update Changelog (Bot) | ${{ needs.changelog-update-dependabot.result }} | ${{ needs.changelog-update-dependabot.outputs.changelog_updated == 'true' && 'Updated' || 'Not applicable' }} |"
            echo "| 🧹 Code Quality (Bot) | ${{ needs.quality-lint-format-bot.result }} | - |"
          else
            echo "| 📋 Check Changelog (User) | ${{ needs.changelog-check-user.result }} | Changes: ${{ needs.changelog-check-user.outputs.has_changes != '0' && 'Yes' || 'No' }} |"
            echo "| ✅ Enforce Changelog | ${{ needs.changelog-enforce-user.result }} | Should block: ${{ needs.changelog-enforce-user.outputs.should_block }} |"
            echo "| 🧹 Code Quality (User) | ${{ needs.quality-lint-format-user.result }} | - |"
          fi

          echo "| 🏷️ PR Milestone Check | ${{ needs.metadata-milestone-check.result }} | - |"

      # Split failure check to its own step with if condition
      - name: Check for job failures
        if: ${{ contains(needs.*.result, 'failure') }}
        run: |
          echo "⛔ One or more checks failed - blocking merge"

          # List which checks failed
          if [[ "${{ needs.initial-author-check.result }}" == "failure" ]]; then
            echo "- ❌ Initial author check failed"
          fi

          if [[ "${{ needs.metadata-milestone-check.result }}" == "failure" ]]; then
            echo "- ❌ Milestone check failed"
          fi

          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            if [[ "${{ needs.quality-lint-format-bot.result }}" == "failure" ]]; then
              echo "- ❌ Code quality checks (bot) failed"
            fi
            if [[ "${{ needs.changelog-update-dependabot.result }}" == "failure" ]]; then
              echo "- ❌ Changelog update for bot failed"
            fi
          else
            if [[ "${{ needs.quality-lint-format-user.result }}" == "failure" ]]; then
              echo "- ❌ Code quality checks (user) failed"
            fi
            if [[ "${{ needs.changelog-check-user.result }}" == "failure" ]]; then
              echo "- ❌ Changelog check failed"
            fi
            if [[ "${{ needs.changelog-enforce-user.result }}" == "failure" ]]; then
              echo "- ❌ Changelog enforcement failed"
            fi
          fi

          exit 1

      - name: Check for skipped jobs (non-bot PR)
        if: ${{ steps.set-status.outputs.is_bot == 'false' }}
        env:
          QUALITY_STATUS: ${{ needs.quality-lint-format-user.result }}
          MILESTONE_STATUS: ${{ needs.metadata-milestone-check.result }}
        run: |
          if [[ "$QUALITY_STATUS" == "skipped" || "$MILESTONE_STATUS" == "skipped" ]]; then
            echo "⚠️ Required checks were skipped - blocking merge"
            
            if [[ "$QUALITY_STATUS" == "skipped" ]]; then
              echo "- ⚠️ Code quality checks were skipped"
            fi
            
            if [[ "$MILESTONE_STATUS" == "skipped" ]]; then
              echo "- ⚠️ Milestone checks were skipped"
            fi
            
            exit 1
          fi

      - name: Check for skipped jobs (bot PR)
        if: ${{ steps.set-status.outputs.is_bot == 'true' }}
        env:
          BOT_QUALITY_STATUS: ${{ needs.quality-lint-format-bot.result }}
          MILESTONE_STATUS: ${{ needs.metadata-milestone-check.result }}
        run: |
          if [[ "$BOT_QUALITY_STATUS" == "skipped" || "$MILESTONE_STATUS" == "skipped" ]]; then
            echo "⚠️ Required checks were skipped - blocking merge"
            
            if [[ "$BOT_QUALITY_STATUS" == "skipped" ]]; then
              echo "- ⚠️ Bot code quality checks were skipped"
            fi
            
            if [[ "$MILESTONE_STATUS" == "skipped" ]]; then
              echo "- ⚠️ Milestone checks were skipped"
            fi
            
            exit 1
          fi

      - name: Success message
        run: |
          echo "✅ All PR checks completed successfully"

          # Provide a summary of what was run
          if [[ "${{ steps.set-status.outputs.is_bot }}" == "true" ]]; then
            echo "Bot PR detected - ran bot-specific workflows"
            echo "- ✓ Initial author check (completed)"
            echo "- ✓ Bot code quality check (completed)"
            echo "- ✓ Milestone check (completed)"
            if [[ "${{ needs.changelog-update-dependabot.result }}" != 'skipped' ]]; then
              echo "- ✓ Changelog auto-update (completed)"
            fi
          else
            echo "User PR detected - ran user-specific workflows"
            echo "- ✓ Initial author check (completed)"
            echo "- ✓ User code quality check (completed)"
            echo "- ✓ Milestone check (completed)"
            if [[ "${{ needs.changelog-check-user.result }}" != 'skipped' ]]; then
              echo "- ✓ Changelog check (completed)"
            fi
          fi

      # Use GitHub API to explicitly report status (works better for Dependabot PRs)
      - name: Explicitly report final status
        if: ${{ always() }}
        uses: actions/github-script@v7.0.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const { owner, repo } = context.repo;
            const prRef = context.payload.pull_request;
            let sha = prRef?.head?.sha;

            if (!sha) {
              console.log('No SHA found in PR head, falling back to event SHA');
              sha = context.sha;
            }

            const jobStatus = '${{ job.status }}';
            const isBot = '${{ steps.set-status.outputs.is_bot }}' === 'true';
            const changelogUpdateOutput = '${{ needs.changelog-update-dependabot.outputs.commit_sha }}';

            // For Dependabot PRs with changelog updates, get the latest commit from the branch
            if (isBot) {
              try {
                // Fetch the latest commit from the PR branch regardless of what we have in event payload
                // This ensures we always use the most up-to-date SHA after any workflow modifications
                const { data: prData } = await github.rest.pulls.get({
                  owner,
                  repo,
                  pull_number: context.payload.pull_request.number
                });
                
                if (prData && prData.head && prData.head.sha) {
                  console.log(`Using latest SHA from PR API: ${prData.head.sha}`);
                  console.log(`Previous SHA from event: ${sha}`);
                  sha = prData.head.sha;
                }
                
                // Additional fallback - if we have a specific commit SHA from changelog update, use it
                if (changelogUpdateOutput && changelogUpdateOutput.length > 0) {
                  console.log(`Changelog update produced commit: ${changelogUpdateOutput}`);
                  console.log(`Comparing to latest PR SHA: ${sha}`);
                  
                  // Only use the changelog commit if it's different from what we already have
                  if (changelogUpdateOutput !== sha) {
                    console.log(`Using changelog update commit SHA: ${changelogUpdateOutput}`);
                    sha = changelogUpdateOutput;
                  }
                }
              } catch (apiError) {
                console.error(`Error fetching latest PR data: ${apiError.message}`);
                console.log(`Falling back to original SHA: ${sha}`);
                // Continue with the original SHA
              }
            } else {
              console.log(`Using original PR head SHA for user PR: ${sha}`);
            }

            console.log(`Reporting final status for ${owner}/${repo}@${sha}: ${jobStatus}`);

            // Set state based on job status
            let state = 'success';
            let description = 'All PR checks completed successfully';

            if (jobStatus !== 'success') {
              state = 'failure';
              description = 'One or more PR checks failed';
            }

            try {
              // Explicitly create a status check for the Final Status Check
              // Note: Removed emoji from context to avoid 4-byte Unicode validation errors
              const statusResponse = await github.rest.repos.createCommitStatus({
                owner,
                repo,
                sha,
                state,
                description,
                context: 'Final Status Check'
              });
              
              console.log(`Status check created with state: ${state}, response status: ${statusResponse.status}`);
            } catch (error) {
              console.error(`Error creating status check: ${error.message}`);
              console.error(`Error details: ${JSON.stringify(error)}`);
              
              // Add a brief backoff before retry to reduce transient API race conditions
              console.log('Adding brief backoff (1 second) before retry...');
              await new Promise(resolve => setTimeout(resolve, 1000));
              
              // Try again with the current context SHA as fallback
              console.log(`Retrying with context SHA: ${context.sha}`);
              try {
                const fallbackResponse = await github.rest.repos.createCommitStatus({
                  owner,
                  repo,
                  sha: context.sha,
                  state,
                  description: description + " (fallback)",
                  context: 'Final Status Check'
                });
                console.log(`Fallback status check created with state: ${state}, response status: ${fallbackResponse.status}`);
              } catch (fallbackError) {
                console.error(`Error creating fallback status check: ${fallbackError.message}`);
                console.error(`Fallback error details: ${JSON.stringify(fallbackError)}`);
                
                // If both attempts fail, add additional logging for troubleshooting
                console.log('Both status creation attempts failed - this may require manual verification');
              }
            }

            // Exit with appropriate code using core.setFailed() for better consistency with GitHub Actions
            if (jobStatus !== 'success') {
              core.setFailed(`One or more PR checks failed with status: ${jobStatus}`);
            }
